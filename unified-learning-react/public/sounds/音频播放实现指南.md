# æ–‡æœ¬è½¬è¯­éŸ³æ’­æ”¾ç³»ç»Ÿå®ç°æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£åŸºäº Earthworm è‹±è¯­å­¦ä¹ åº”ç”¨çš„å®ç°ç»éªŒï¼Œè¯¦ç»†ä»‹ç»å¦‚ä½•æ„å»ºä¸€ä¸ªå®Œæ•´çš„æ–‡æœ¬è½¬è¯­éŸ³æ’­æ”¾ç³»ç»Ÿã€‚è¯¥ç³»ç»Ÿç»“åˆäº†ç¬¬ä¸‰æ–¹ TTS æœåŠ¡å’Œæœ¬åœ°éŸ³æ•ˆï¼Œæä¾›äº†ä¸°å¯Œçš„éŸ³é¢‘äº¤äº’åŠŸèƒ½ã€‚

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

```
éŸ³é¢‘æ’­æ”¾ç³»ç»Ÿ
â”œâ”€â”€ TTS æœåŠ¡å±‚ (æœ‰é“è¯å…¸ API)
â”œâ”€â”€ éŸ³é¢‘ç®¡ç†å±‚ (HTML5 Audio)
â”œâ”€â”€ é…ç½®ç®¡ç†å±‚ (ç”¨æˆ·åå¥½è®¾ç½®)
â”œâ”€â”€ éŸ³æ•ˆç³»ç»Ÿå±‚ (æœ¬åœ°éŸ³é¢‘æ–‡ä»¶)
â””â”€â”€ ä¸šåŠ¡é€»è¾‘å±‚ (å„ç§æ’­æ”¾åœºæ™¯)
```

## ğŸš€ æ ¸å¿ƒå®ç°

### 1. å‘éŸ³é…ç½®ç®¡ç†

é¦–å…ˆåˆ›å»ºå‘éŸ³ç±»å‹å’Œé…ç½®ç®¡ç†ï¼š

```typescript
// composables/user/pronunciation.ts

export enum PronunciationType {
  American = "American",
  British = "British",
}

export const pronunciationLabels: { [key in PronunciationType]: string } = {
  [PronunciationType.American]: "ç¾éŸ³",
  [PronunciationType.British]: "è‹±éŸ³",
};

const PRONUNCIATION_TYPE = "pronunciationType";
const pronunciation = ref<PronunciationType>(PronunciationType.American);

export function usePronunciation() {
  loadCache();

  function loadCache() {
    const type = getStore() || pronunciation.value;
    setStore(type);
  }

  function setStore(value: PronunciationType) {
    pronunciation.value = value;
    localStorage.setItem(PRONUNCIATION_TYPE, value);
  }

  function getStore(): PronunciationType {
    return localStorage.getItem(PRONUNCIATION_TYPE) as PronunciationType;
  }

  function getPronunciationType(): number {
    return pronunciation.value === PronunciationType.American ? 2 : 1;
  }

  function getPronunciationOptions() {
    return Object.entries(pronunciationLabels).map(([key, value]) => ({
      label: value,
      value: key,
    }));
  }

  /**
   * ç”Ÿæˆæœ‰é“è¯å…¸ TTS API URL
   * ç¾å¼å‘éŸ³ï¼štype=2
   * è‹±å¼å‘éŸ³ï¼štype=1
   */
  function getPronunciationUrl(english: string | undefined): string {
    if (!english) return '';
    return `https://dict.youdao.com/dictvoice?type=${getPronunciationType()}&audio=${encodeURIComponent(english)}`;
  }

  function togglePronunciation(type: PronunciationType) {
    if (type !== pronunciation.value) setStore(type);
  }

  return {
    pronunciation,
    getPronunciationOptions,
    getPronunciationUrl,
    togglePronunciation,
  };
}
```

### 2. æ ¸å¿ƒéŸ³é¢‘æ’­æ”¾å™¨

åˆ›å»ºåŸºç¡€çš„éŸ³é¢‘æ’­æ”¾åŠŸèƒ½ï¼š

```typescript
// composables/audio/audioPlayer.ts

export interface PlayOptions {
  times?: number;      // æ’­æ”¾æ¬¡æ•°
  rate?: number;       // æ’­æ”¾é€Ÿåº¦ (0.5-2.0)
  interval?: number;   // é‡å¤æ’­æ”¾é—´éš” (æ¯«ç§’)
}

const DefaultPlayOptions: PlayOptions = {
  times: 1,
  rate: 1,
  interval: 500,
};

// å…¨å±€éŸ³é¢‘å®ä¾‹
const globalAudio = new Audio();

export function updateAudioSource(src: string) {
  if (!src) return;
  
  globalAudio.src = src;
  globalAudio.load();
}

export function playAudio(playOptions?: PlayOptions) {
  const { times, rate, interval } = Object.assign({}, DefaultPlayOptions, playOptions);

  globalAudio.playbackRate = rate;
  
  // æ’­æ”¾éŸ³é¢‘
  const playPromise = globalAudio.play();
  
  // å¤„ç†æ’­æ”¾å¤±è´¥çš„æƒ…å†µ
  if (playPromise !== undefined) {
    playPromise.catch(error => {
      console.warn('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error);
    });
  }

  // å¤šæ¬¡æ’­æ”¾é€»è¾‘
  if (times > 1) {
    globalAudio.addEventListener("ended", handleEnded, false);
  }

  let playCount = 1;
  let timeoutId: NodeJS.Timeout;

  function handleEnded() {
    if (playCount < times) {
      timeoutId = setTimeout(() => {
        globalAudio.play();
        playCount++;
      }, interval);
    } else {
      // æ¸…ç†ç›‘å¬å™¨
      globalAudio.removeEventListener("ended", handleEnded);
      playCount = 1;
    }
  }

  // è¿”å›åœæ­¢æ’­æ”¾çš„å‡½æ•°
  return () => {
    globalAudio.pause();
    globalAudio.currentTime = 0;
    globalAudio.removeEventListener("ended", handleEnded);
    if (timeoutId) clearTimeout(timeoutId);
  };
}

/**
 * å•è¯çº§åˆ«çš„éŸ³é¢‘æ’­æ”¾å™¨
 * é¿å…é‡å¤æ’­æ”¾ç›¸åŒå•è¯
 */
export function useWordAudioPlayer() {
  const wordAudio = new Audio();
  let lastWord = "";
  let isPlaying = false;

  wordAudio.onplay = () => {
    isPlaying = true;
  };

  wordAudio.onended = () => {
    isPlaying = false;
  };

  wordAudio.onerror = () => {
    isPlaying = false;
    console.warn('å•è¯éŸ³é¢‘æ’­æ”¾å¤±è´¥:', lastWord);
  };

  function playWord(word: string, pronunciationUrl: string) {
    // å¦‚æœæ­£åœ¨æ’­æ”¾ç›¸åŒå•è¯ï¼Œåˆ™è·³è¿‡
    if (isPlaying && lastWord === word) {
      return;
    }

    lastWord = word;
    wordAudio.src = pronunciationUrl;
    
    const playPromise = wordAudio.play();
    if (playPromise !== undefined) {
      playPromise.catch(error => {
        console.warn('å•è¯æ’­æ”¾å¤±è´¥:', word, error);
      });
    }
  }

  return {
    playWord,
    isPlaying: () => isPlaying,
  };
}
```

### 3. TTS æœåŠ¡é›†æˆ

åˆ›å»ºæ–‡æœ¬è½¬è¯­éŸ³çš„æ ¸å¿ƒæœåŠ¡ï¼š

```typescript
// composables/audio/ttsService.ts

import { watchEffect } from "vue";
import { usePronunciation } from "../user/pronunciation";
import { updateAudioSource, playAudio, type PlayOptions } from "./audioPlayer";

export function useTTSService() {
  const { getPronunciationUrl } = usePronunciation();
  let lastPronunciationUrl = "";

  /**
   * ä¸ºæŒ‡å®šæ–‡æœ¬è®¾ç½®éŸ³é¢‘æº
   */
  function setTextAudio(text: string) {
    if (!text) return;
    
    const pronunciationUrl = getPronunciationUrl(text);
    if (lastPronunciationUrl !== pronunciationUrl) {
      updateAudioSource(pronunciationUrl);
      lastPronunciationUrl = pronunciationUrl;
    }
  }

  /**
   * æ’­æ”¾æŒ‡å®šæ–‡æœ¬çš„è¯­éŸ³
   */
  function speakText(text: string, options?: PlayOptions) {
    setTextAudio(text);
    return playAudio(options);
  }

  /**
   * æ’­æ”¾å½“å‰è®¾ç½®çš„éŸ³é¢‘
   */
  function speak(options?: PlayOptions) {
    return playAudio(options);
  }

  return {
    setTextAudio,
    speakText,
    speak,
  };
}

/**
 * å“åº”å¼æ–‡æœ¬è¯­éŸ³æ’­æ”¾
 * å½“æ–‡æœ¬å˜åŒ–æ—¶è‡ªåŠ¨æ›´æ–°éŸ³é¢‘æº
 */
export function useReactiveTTS(textRef: Ref<string | undefined>) {
  const { setTextAudio, speak } = useTTSService();

  // ç›‘å¬æ–‡æœ¬å˜åŒ–ï¼Œè‡ªåŠ¨æ›´æ–°éŸ³é¢‘æº
  watchEffect(() => {
    const text = textRef.value;
    if (text) {
      setTextAudio(text);
    }
  });

  return {
    speak,
  };
}
```

### 4. ç”¨æˆ·åå¥½è®¾ç½®

åˆ›å»ºéŸ³é¢‘ç›¸å…³çš„ç”¨æˆ·è®¾ç½®ï¼š

```typescript
// composables/user/audioSettings.ts

import { useLocalStorageBoolean } from "~/utils/localStorage";

// å­˜å‚¨é”®åå¸¸é‡
export const AUTO_PRONUNCIATION = "autoPronunciation";
export const KEYBOARD_SOUND_KEY = "keyboardSoundEnabled";
export const AUTO_PLAY_ENGLISH = "autoPlayEnglish";

/**
 * è‡ªåŠ¨å‘éŸ³è®¾ç½®
 */
export function useAutoPronunciation() {
  const {
    value: autoPlaySound,
    isTrue: isAutoPlaySound,
    toggle: toggleAutoPlaySound,
    remove: removeAutoPlaySound,
  } = useLocalStorageBoolean(AUTO_PRONUNCIATION, true);

  return {
    autoPlaySound,
    isAutoPlaySound,
    toggleAutoPlaySound,
    removeAutoPlaySound,
  };
}

/**
 * é”®ç›˜éŸ³æ•ˆè®¾ç½®
 */
export function useKeyboardSound() {
  const {
    value: keyboardSound,
    isTrue: isKeyboardSoundEnabled,
    toggle: toggleKeyboardSound,
    remove: removeKeyboardSound,
  } = useLocalStorageBoolean(KEYBOARD_SOUND_KEY, true);

  return {
    keyboardSound,
    isKeyboardSoundEnabled,
    toggleKeyboardSound,
    removeKeyboardSound,
  };
}

/**
 * è‡ªåŠ¨æ’­æ”¾è‹±è¯­è®¾ç½®
 */
export function useAutoPlayEnglish() {
  const {
    value: autoPlayEnglish,
    isTrue: isAutoPlayEnglish,
    toggle: toggleAutoPlayEnglish,
    remove: removeAutoPlayEnglish,
  } = useLocalStorageBoolean(AUTO_PLAY_ENGLISH, true);

  return {
    autoPlayEnglish,
    isAutoPlayEnglish,
    toggleAutoPlayEnglish,
    removeAutoPlayEnglish,
  };
}

// localStorage å¸ƒå°”å€¼å·¥å…·å‡½æ•°
export function useLocalStorageBoolean(key: string, defaultValue: boolean = false) {
  const value = ref(defaultValue);

  // åˆå§‹åŒ–æ—¶ä» localStorage è¯»å–
  const stored = localStorage.getItem(key);
  if (stored !== null) {
    value.value = stored === 'true';
  } else {
    localStorage.setItem(key, String(defaultValue));
  }

  const isTrue = () => value.value;
  const isFalse = () => !value.value;
  
  const toggle = () => {
    value.value = !value.value;
    localStorage.setItem(key, String(value.value));
  };

  const set = (newValue: boolean) => {
    value.value = newValue;
    localStorage.setItem(key, String(newValue));
  };

  const remove = () => {
    localStorage.removeItem(key);
    value.value = defaultValue;
  };

  return {
    value,
    isTrue,
    isFalse,
    toggle,
    set,
    remove,
  };
}
```

### 5. æœ¬åœ°éŸ³æ•ˆç³»ç»Ÿ

å®ç°é”®ç›˜éŸ³æ•ˆå’Œæç¤ºéŸ³ï¼š

```typescript
// composables/audio/soundEffects.ts

// éŸ³æ•ˆæ–‡ä»¶è·¯å¾„
import errorSoundPath from "~/assets/sounds/error.mp3";
import rightSoundPath from "~/assets/sounds/right.mp3";
import typingSoundPath from "~/assets/sounds/typing.mp3";

/**
 * æç¤ºéŸ³æ’­æ”¾å™¨
 */
export function useTipSounds() {
  const rightAudio = new Audio(rightSoundPath);
  const errorAudio = new Audio(errorSoundPath);

  // é¢„åŠ è½½éŸ³é¢‘
  rightAudio.preload = 'auto';
  errorAudio.preload = 'auto';

  function playRightSound() {
    rightAudio.currentTime = 0; // é‡ç½®æ’­æ”¾ä½ç½®
    rightAudio.play().catch(console.warn);
  }

  function playErrorSound() {
    errorAudio.currentTime = 0;
    errorAudio.play().catch(console.warn);
  }

  return {
    playRightSound,
    playErrorSound,
  };
}

/**
 * é”®ç›˜æ‰“å­—éŸ³æ•ˆ
 * ä½¿ç”¨ Web Audio API å®ç°ä½å»¶è¿Ÿæ’­æ”¾
 */
export function useTypingSounds() {
  const PLAY_INTERVAL_TIME = 60; // æ’­æ”¾é—´éš”é™åˆ¶ (æ¯«ç§’)
  const lastPlayTime = ref(0);
  
  let audioCtx: AudioContext | null = null;
  let audioBuffer: AudioBuffer | null = null;

  // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
  async function initAudioContext() {
    if (!audioCtx) {
      audioCtx = new AudioContext();
      await loadAudioBuffer();
    }
  }

  // åŠ è½½éŸ³é¢‘ç¼“å†²åŒº
  async function loadAudioBuffer() {
    if (!audioCtx) return;

    try {
      const response = await fetch(typingSoundPath);
      const arrayBuffer = await response.arrayBuffer();
      audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
    } catch (error) {
      console.warn('åŠ è½½æ‰“å­—éŸ³æ•ˆå¤±è´¥:', error);
    }
  }

  // æ’­æ”¾æ‰“å­—éŸ³æ•ˆ
  function playTypingSound() {
    const now = Date.now();
    
    // é¢‘ç‡é™åˆ¶
    if (now - lastPlayTime.value < PLAY_INTERVAL_TIME) return;
    if (!audioCtx || !audioBuffer) return;

    try {
      const source = audioCtx.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(audioCtx.destination);
      source.start();
      
      lastPlayTime.value = now;
      
      // æ’­æ”¾ç»“æŸåæ¸…ç†èµ„æº
      source.onended = () => {
        source.disconnect();
      };
    } catch (error) {
      console.warn('æ’­æ”¾æ‰“å­—éŸ³æ•ˆå¤±è´¥:', error);
    }
  }

  // æ£€æŸ¥æ˜¯å¦åº”è¯¥æ’­æ”¾æ‰“å­—éŸ³æ•ˆ
  function shouldPlayTypingSound(e: KeyboardEvent): boolean {
    // å¿½ç•¥ä¿®é¥°é”®
    if (e.altKey || e.ctrlKey || e.metaKey) return false;
    
    // åªå¯¹å­—æ¯æ•°å­—å’Œç‰¹å®šç¬¦å·æ’­æ”¾éŸ³æ•ˆ
    return /^[a-zA-Z0-9]$/.test(e.key) || ["Backspace", " ", "'"].includes(e.key);
  }

  // åˆå§‹åŒ–ï¼ˆåœ¨ç»„ä»¶æŒ‚è½½æ—¶è°ƒç”¨ï¼‰
  onMounted(() => {
    initAudioContext();
  });

  return {
    playTypingSound,
    shouldPlayTypingSound,
  };
}
```

### 6. ä¸šåŠ¡åœºæ™¯å®ç°

#### A. å¥å­æœ—è¯»ç»„ä»¶

```typescript
// composables/business/sentenceReader.ts

export function useSentenceReader(sentenceRef: Ref<string | undefined>) {
  const { speak } = useReactiveTTS(sentenceRef);
  const { isAutoPlaySound } = useAutoPronunciation();

  // è‡ªåŠ¨æ’­æ”¾ï¼ˆåœ¨ç»„ä»¶æŒ‚è½½æ—¶ï¼‰
  onMounted(() => {
    if (isAutoPlaySound()) {
      speak();
    }
  });

  // æ‰‹åŠ¨æ’­æ”¾
  function playSentence(options?: PlayOptions) {
    return speak(options);
  }

  return {
    playSentence,
  };
}
```

#### B. å•è¯ç‚¹å‡»æ’­æ”¾

```typescript
// composables/business/wordPlayer.ts

export function useWordPlayer() {
  const { getPronunciationUrl } = usePronunciation();
  const { playWord } = useWordAudioPlayer();

  function playWordSound(word: string) {
    if (!word) return;
    
    const pronunciationUrl = getPronunciationUrl(word);
    playWord(word, pronunciationUrl);
  }

  return {
    playWordSound,
  };
}
```

#### C. å¬å†™æ¨¡å¼æ’­æ”¾å™¨

```typescript
// composables/business/dictationPlayer.ts

interface DictationOptions {
  times: number;
  rate: number;
  interval: number;
}

const DEFAULT_DICTATION_OPTIONS: DictationOptions = {
  times: 1,
  rate: 1,
  interval: 1000,
};

export function useDictationPlayer() {
  const options = reactive({ ...DEFAULT_DICTATION_OPTIONS });
  const { speak } = useTTSService();

  // ä»æœ¬åœ°å­˜å‚¨æ¢å¤è®¾ç½®
  function loadOptions() {
    const stored = localStorage.getItem('dictationOptions');
    if (stored) {
      Object.assign(options, JSON.parse(stored));
    }
  }

  // ä¿å­˜è®¾ç½®åˆ°æœ¬åœ°å­˜å‚¨
  function saveOptions() {
    localStorage.setItem('dictationOptions', JSON.stringify(options));
  }

  // é‡ç½®è®¾ç½®
  function resetOptions() {
    Object.assign(options, DEFAULT_DICTATION_OPTIONS);
  }

  // æ’­æ”¾å¬å†™éŸ³é¢‘
  function playDictation() {
    const { times, rate, interval } = options;
    return speak({ times, rate, interval });
  }

  // åˆå§‹åŒ–
  loadOptions();

  return {
    options,
    loadOptions,
    saveOptions,
    resetOptions,
    playDictation,
  };
}
```

### 7. Vue ç»„ä»¶ä½¿ç”¨ç¤ºä¾‹

#### A. åŸºç¡€è¯­éŸ³æ’­æ”¾ç»„ä»¶

```vue
<template>
  <div class="audio-player">
    <!-- æ’­æ”¾æŒ‰é’® -->
    <button 
      @click="handlePlay"
      class="play-btn"
      :disabled="!currentText"
    >
      <Icon name="speaker" />
      æ’­æ”¾
    </button>

    <!-- å•è¯ç‚¹å‡»æ’­æ”¾ -->
    <div class="words-container">
      <span 
        v-for="word in words" 
        :key="word"
        @click="playWord(word)"
        class="clickable-word"
      >
        {{ word }}
      </span>
    </div>

    <!-- éŸ³æ ‡æ˜¾ç¤º -->
    <div class="phonetic" v-if="phonetic">
      {{ phonetic }}
    </div>
  </div>
</template>

<script setup lang="ts">
interface Props {
  text?: string;
  phonetic?: string;
  autoPlay?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  autoPlay: false,
});

const currentText = toRef(props, 'text');
const words = computed(() => currentText.value?.split(' ') || []);

// ä½¿ç”¨å¥å­é˜…è¯»å™¨
const { playSentence } = useSentenceReader(currentText);

// ä½¿ç”¨å•è¯æ’­æ”¾å™¨
const { playWordSound } = useWordPlayer();

// æ‰‹åŠ¨æ’­æ”¾
function handlePlay() {
  playSentence();
}

// æ’­æ”¾å•è¯
function playWord(word: string) {
  playWordSound(word);
}
</script>

<style scoped>
.clickable-word {
  @apply cursor-pointer hover:text-blue-500 mx-1;
}

.play-btn {
  @apply flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50;
}

.phonetic {
  @apply text-gray-500 text-lg mt-2;
}
</style>
```

#### B. å¬å†™æ¨¡å¼ç»„ä»¶

```vue
<template>
  <div class="dictation-player">
    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="controls">
      <div class="control-group">
        <label>æ’­æ”¾æ¬¡æ•°:</label>
        <select v-model="options.times">
          <option v-for="n in 5" :key="n" :value="n">{{ n }}</option>
        </select>
      </div>

      <div class="control-group">
        <label>æ’­æ”¾é€Ÿåº¦:</label>
        <select v-model="options.rate">
          <option value="0.5">0.5x</option>
          <option value="0.75">0.75x</option>
          <option value="1">1x</option>
          <option value="1.25">1.25x</option>
          <option value="1.5">1.5x</option>
        </select>
      </div>

      <div class="control-group">
        <label>é—´éš”æ—¶é—´:</label>
        <select v-model="options.interval">
          <option value="500">0.5ç§’</option>
          <option value="1000">1ç§’</option>
          <option value="1500">1.5ç§’</option>
          <option value="2000">2ç§’</option>
        </select>
      </div>
    </div>

    <!-- æ’­æ”¾æŒ‰é’® -->
    <button @click="play" class="play-button">
      <Icon name="play" />
      æ’­æ”¾å¬å†™
    </button>
  </div>
</template>

<script setup lang="ts">
const { options, saveOptions, playDictation } = useDictationPlayer();

// ç›‘å¬é€‰é¡¹å˜åŒ–å¹¶ä¿å­˜
watch(options, saveOptions, { deep: true });

function play() {
  playDictation();
}
</script>
```

#### C. è®¾ç½®é¢æ¿ç»„ä»¶

```vue
<template>
  <div class="audio-settings">
    <h3>éŸ³é¢‘è®¾ç½®</h3>

    <!-- å‘éŸ³ç±»å‹ -->
    <div class="setting-item">
      <label>å‘éŸ³ç±»å‹:</label>
      <div class="radio-group">
        <label v-for="option in pronunciationOptions" :key="option.value">
          <input 
            type="radio" 
            :value="option.value"
            :checked="pronunciation === option.value"
            @change="togglePronunciation(option.value as PronunciationType)"
          />
          {{ option.label }}
        </label>
      </div>
    </div>

    <!-- è‡ªåŠ¨æ’­æ”¾è®¾ç½® -->
    <div class="setting-item">
      <label>
        <input 
          type="checkbox" 
          :checked="autoPlaySound"
          @change="toggleAutoPlaySound"
        />
        ç­”é¢˜åè‡ªåŠ¨æ’­æ”¾å‘éŸ³
      </label>
    </div>

    <!-- é”®ç›˜éŸ³æ•ˆ -->
    <div class="setting-item">
      <label>
        <input 
          type="checkbox" 
          :checked="keyboardSound"
          @change="toggleKeyboardSound"
        />
        å¯ç”¨é”®ç›˜éŸ³æ•ˆ
      </label>
    </div>

    <!-- è‡ªåŠ¨æ’­æ”¾è‹±è¯­ -->
    <div class="setting-item">
      <label>
        <input 
          type="checkbox" 
          :checked="autoPlayEnglish"
          @change="toggleAutoPlayEnglish"
        />
        é¢˜ç›®æ˜¾ç¤ºæ—¶è‡ªåŠ¨æ’­æ”¾
      </label>
    </div>
  </div>
</template>

<script setup lang="ts">
const { 
  pronunciation, 
  getPronunciationOptions, 
  togglePronunciation 
} = usePronunciation();

const { autoPlaySound, toggleAutoPlaySound } = useAutoPronunciation();
const { keyboardSound, toggleKeyboardSound } = useKeyboardSound();
const { autoPlayEnglish, toggleAutoPlayEnglish } = useAutoPlayEnglish();

const pronunciationOptions = getPronunciationOptions();
</script>
```

### 8. è¾“å…¥æ¡†éŸ³æ•ˆé›†æˆ

```vue
<template>
  <input
    v-model="inputValue"
    @keydown="handleKeydown"
    @input="handleInput"
    class="audio-input"
    placeholder="è¯·è¾“å…¥å†…å®¹..."
  />
</template>

<script setup lang="ts">
const inputValue = ref('');

const { isKeyboardSoundEnabled } = useKeyboardSound();
const { playTypingSound, shouldPlayTypingSound } = useTypingSounds();
const { playRightSound, playErrorSound } = useTipSounds();

function handleKeydown(e: KeyboardEvent) {
  // æ’­æ”¾é”®ç›˜éŸ³æ•ˆ
  if (isKeyboardSoundEnabled() && shouldPlayTypingSound(e)) {
    playTypingSound();
  }
}

function handleInput() {
  // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ è¾“å…¥éªŒè¯é€»è¾‘
  // æ ¹æ®éªŒè¯ç»“æœæ’­æ”¾ä¸åŒéŸ³æ•ˆ
}

// éªŒè¯æˆåŠŸæ—¶è°ƒç”¨
function onValidationSuccess() {
  playRightSound();
}

// éªŒè¯å¤±è´¥æ—¶è°ƒç”¨
function onValidationError() {
  playErrorSound();
}
</script>
```

## ğŸ”§ å·¥å…·å‡½æ•°

### éŸ³é¢‘é¢„åŠ è½½å·¥å…·

```typescript
// utils/audioPreloader.ts

export class AudioPreloader {
  private audioCache = new Map<string, HTMLAudioElement>();

  /**
   * é¢„åŠ è½½éŸ³é¢‘æ–‡ä»¶
   */
  async preloadAudio(url: string): Promise<HTMLAudioElement> {
    if (this.audioCache.has(url)) {
      return this.audioCache.get(url)!;
    }

    const audio = new Audio();
    audio.preload = 'auto';
    
    return new Promise((resolve, reject) => {
      audio.addEventListener('canplaythrough', () => {
        this.audioCache.set(url, audio);
        resolve(audio);
      });

      audio.addEventListener('error', () => {
        reject(new Error(`Failed to load audio: ${url}`));
      });

      audio.src = url;
    });
  }

  /**
   * æ‰¹é‡é¢„åŠ è½½
   */
  async preloadMultiple(urls: string[]): Promise<void> {
    const promises = urls.map(url => this.preloadAudio(url));
    await Promise.allSettled(promises);
  }

  /**
   * è·å–ç¼“å­˜çš„éŸ³é¢‘
   */
  getCachedAudio(url: string): HTMLAudioElement | null {
    return this.audioCache.get(url) || null;
  }

  /**
   * æ¸…ç†ç¼“å­˜
   */
  clearCache(): void {
    this.audioCache.clear();
  }
}

// å…¨å±€å®ä¾‹
export const audioPreloader = new AudioPreloader();
```

### éŸ³é¢‘çŠ¶æ€ç®¡ç†

```typescript
// utils/audioStatus.ts

export enum AudioStatus {
  IDLE = 'idle',
  LOADING = 'loading',
  PLAYING = 'playing',
  PAUSED = 'paused',
  ERROR = 'error',
}

export function useAudioStatus() {
  const status = ref<AudioStatus>(AudioStatus.IDLE);
  const error = ref<string | null>(null);

  function setStatus(newStatus: AudioStatus, errorMessage?: string) {
    status.value = newStatus;
    error.value = errorMessage || null;
  }

  function isPlaying() {
    return status.value === AudioStatus.PLAYING;
  }

  function isLoading() {
    return status.value === AudioStatus.LOADING;
  }

  function hasError() {
    return status.value === AudioStatus.ERROR;
  }

  return {
    status: readonly(status),
    error: readonly(error),
    setStatus,
    isPlaying,
    isLoading,
    hasError,
  };
}
```

## ğŸ“¦ èµ„æºæ–‡ä»¶å‡†å¤‡

### 1. éŸ³æ•ˆæ–‡ä»¶

åœ¨é¡¹ç›®ä¸­åˆ›å»º `assets/sounds/` ç›®å½•ï¼Œå¹¶å‡†å¤‡ä»¥ä¸‹éŸ³é¢‘æ–‡ä»¶ï¼š

```
assets/sounds/
â”œâ”€â”€ typing.mp3      # é”®ç›˜æ‰“å­—éŸ³æ•ˆ
â”œâ”€â”€ right.mp3       # æ­£ç¡®æç¤ºéŸ³
â”œâ”€â”€ error.mp3       # é”™è¯¯æç¤ºéŸ³
â””â”€â”€ notification.mp3 # é€šçŸ¥éŸ³æ•ˆ
```

### 2. éŸ³é¢‘æ–‡ä»¶è¦æ±‚

- **æ ¼å¼**: MP3 (å…¼å®¹æ€§æœ€å¥½)
- **å¤§å°**: å»ºè®®æ¯ä¸ªæ–‡ä»¶å°äº 100KB
- **æ—¶é•¿**: éŸ³æ•ˆæ–‡ä»¶å»ºè®® 0.1-1 ç§’
- **é‡‡æ ·ç‡**: 44.1kHz
- **æ¯”ç‰¹ç‡**: 128kbps

## ğŸ› ï¸ é…ç½®å’Œä¼˜åŒ–

### 1. Nuxt.js é…ç½®

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  // é¢„åŠ è½½éŸ³é¢‘èµ„æº
  app: {
    head: {
      link: [
        { rel: 'preload', href: '/sounds/typing.mp3', as: 'audio' },
        { rel: 'preload', href: '/sounds/right.mp3', as: 'audio' },
        { rel: 'preload', href: '/sounds/error.mp3', as: 'audio' },
      ]
    }
  },

  // é™æ€èµ„æºé…ç½®
  nitro: {
    publicAssets: [
      {
        baseURL: '/sounds',
        dir: 'assets/sounds'
      }
    ]
  }
});
```

### 2. æ€§èƒ½ä¼˜åŒ–å»ºè®®

```typescript
// composables/audio/optimization.ts

/**
 * éŸ³é¢‘æ€§èƒ½ä¼˜åŒ–å·¥å…·
 */
export function useAudioOptimization() {
  // é˜²æŠ–æ’­æ”¾
  const debouncedPlay = debounce((playFn: () => void) => {
    playFn();
  }, 100);

  // èŠ‚æµæ’­æ”¾
  const throttledPlay = throttle((playFn: () => void) => {
    playFn();
  }, 200);

  // æ£€æŸ¥éŸ³é¢‘æ”¯æŒ
  function checkAudioSupport(): boolean {
    return !!(window.Audio);
  }

  // æ£€æŸ¥ Web Audio API æ”¯æŒ
  function checkWebAudioSupport(): boolean {
    return !!(window.AudioContext || window.webkitAudioContext);
  }

  // è·å–éŸ³é¢‘æ ¼å¼æ”¯æŒ
  function getSupportedFormats(): string[] {
    const audio = new Audio();
    const formats = ['mp3', 'wav', 'ogg', 'aac'];
    
    return formats.filter(format => {
      return audio.canPlayType(`audio/${format}`) !== '';
    });
  }

  return {
    debouncedPlay,
    throttledPlay,
    checkAudioSupport,
    checkWebAudioSupport,
    getSupportedFormats,
  };
}

// é˜²æŠ–å‡½æ•°
function debounce(func: Function, wait: number) {
  let timeout: NodeJS.Timeout;
  return function executedFunction(...args: any[]) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// èŠ‚æµå‡½æ•°
function throttle(func: Function, limit: number) {
  let inThrottle: boolean;
  return function executedFunction(...args: any[]) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}
```

## ğŸš¨ é”™è¯¯å¤„ç†å’Œå…œåº•æ–¹æ¡ˆ

### 1. éŸ³é¢‘æ’­æ”¾å¤±è´¥å¤„ç†

```typescript
// composables/audio/errorHandling.ts

export function useAudioErrorHandling() {
  const retryCount = ref(0);
  const maxRetries = 3;

  async function playWithRetry(
    playFn: () => Promise<void>, 
    onError?: (error: Error) => void
  ) {
    try {
      await playFn();
      retryCount.value = 0; // é‡ç½®é‡è¯•æ¬¡æ•°
    } catch (error) {
      console.warn('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error);
      
      if (retryCount.value < maxRetries) {
        retryCount.value++;
        setTimeout(() => playWithRetry(playFn, onError), 1000);
      } else {
        onError?.(error as Error);
        retryCount.value = 0;
      }
    }
  }

  function handleAudioError(error: Error) {
    // è®°å½•é”™è¯¯
    console.error('éŸ³é¢‘ç³»ç»Ÿé”™è¯¯:', error);
    
    // æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„æç¤º
    showErrorNotification('éŸ³é¢‘æ’­æ”¾å‡ºç°é—®é¢˜ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
    
    // å‘é€é”™è¯¯æŠ¥å‘Šï¼ˆå¯é€‰ï¼‰
    // reportError(error);
  }

  return {
    playWithRetry,
    handleAudioError,
  };
}

function showErrorNotification(message: string) {
  // å®ç°é”™è¯¯æç¤ºé€»è¾‘
  console.warn(message);
}
```

### 2. ç½‘ç»œçŠ¶æ€æ£€æµ‹

```typescript
// composables/audio/networkStatus.ts

export function useNetworkAudioFallback() {
  const isOnline = ref(navigator.onLine);
  const useOfflineMode = ref(false);

  // ç›‘å¬ç½‘ç»œçŠ¶æ€
  window.addEventListener('online', () => {
    isOnline.value = true;
    useOfflineMode.value = false;
  });

  window.addEventListener('offline', () => {
    isOnline.value = false;
    useOfflineMode.value = true;
  });

  function getAudioUrl(text: string): string {
    if (useOfflineMode.value) {
      // ç¦»çº¿æ¨¡å¼ä¸‹çš„å…œåº•æ–¹æ¡ˆ
      return getFallbackAudioUrl(text);
    }
    
    // åœ¨çº¿æ¨¡å¼ä½¿ç”¨ TTS æœåŠ¡
    const { getPronunciationUrl } = usePronunciation();
    return getPronunciationUrl(text);
  }

  function getFallbackAudioUrl(text: string): string {
    // è¿”å›æœ¬åœ°éŸ³é¢‘æ–‡ä»¶æˆ–é™é»˜éŸ³é¢‘
    return '/sounds/silence.mp3';
  }

  return {
    isOnline: readonly(isOnline),
    useOfflineMode: readonly(useOfflineMode),
    getAudioUrl,
  };
}
```

## ğŸ“± ç§»åŠ¨ç«¯é€‚é…

### 1. è§¦æ‘¸äº‹ä»¶å¤„ç†

```typescript
// composables/audio/mobileSupport.ts

export function useMobileAudioSupport() {
  const isMobile = ref(false);
  const audioContext = ref<AudioContext | null>(null);

  onMounted(() => {
    // æ£€æµ‹ç§»åŠ¨è®¾å¤‡
    isMobile.value = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
      navigator.userAgent
    );

    // ç§»åŠ¨ç«¯éœ€è¦ç”¨æˆ·äº¤äº’æ‰èƒ½æ’­æ”¾éŸ³é¢‘
    if (isMobile.value) {
      document.addEventListener('touchstart', initAudioContext, { once: true });
      document.addEventListener('click', initAudioContext, { once: true });
    }
  });

  function initAudioContext() {
    if (!audioContext.value) {
      audioContext.value = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    // æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡
    if (audioContext.value.state === 'suspended') {
      audioContext.value.resume();
    }
  }

  return {
    isMobile: readonly(isMobile),
    audioContext: readonly(audioContext),
    initAudioContext,
  };
}
```

### 2. éŸ³é¢‘æƒé™å¤„ç†

```typescript
// composables/audio/permissions.ts

export function useAudioPermissions() {
  const hasPermission = ref(false);
  const permissionStatus = ref<'granted' | 'denied' | 'prompt'>('prompt');

  async function requestAudioPermission(): Promise<boolean> {
    try {
      // å°è¯•æ’­æ”¾é™éŸ³éŸ³é¢‘æ¥è·å–æƒé™
      const audio = new Audio();
      audio.volume = 0;
      audio.muted = true;
      
      await audio.play();
      audio.pause();
      
      hasPermission.value = true;
      permissionStatus.value = 'granted';
      return true;
    } catch (error) {
      hasPermission.value = false;
      permissionStatus.value = 'denied';
      return false;
    }
  }

  return {
    hasPermission: readonly(hasPermission),
    permissionStatus: readonly(permissionStatus),
    requestAudioPermission,
  };
}
```

## ğŸ§ª æµ‹è¯•ç”¨ä¾‹

### 1. å•å…ƒæµ‹è¯•

```typescript
// tests/audio.spec.ts

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { useTTSService } from '~/composables/audio/ttsService';

// Mock Audio API
global.Audio = vi.fn(() => ({
  play: vi.fn().mockResolvedValue(undefined),
  pause: vi.fn(),
  load: vi.fn(),
  addEventListener: vi.fn(),
  removeEventListener: vi.fn(),
  src: '',
  currentTime: 0,
  playbackRate: 1,
}));

describe('TTS Service', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should create audio instance', () => {
    const { speakText } = useTTSService();
    expect(speakText).toBeDefined();
  });

  it('should play text audio', async () => {
    const { speakText } = useTTSService();
    const mockAudio = new Audio();
    
    await speakText('hello world');
    
    expect(mockAudio.play).toHaveBeenCalled();
  });

  it('should handle play options', async () => {
    const { speakText } = useTTSService();
    const mockAudio = new Audio();
    
    await speakText('hello', { rate: 1.5, times: 2 });
    
    expect(mockAudio.playbackRate).toBe(1.5);
  });
});
```

### 2. é›†æˆæµ‹è¯•

```typescript
// tests/integration/audioPlayer.spec.ts

import { mount } from '@vue/test-utils';
import AudioPlayer from '~/components/AudioPlayer.vue';

describe('AudioPlayer Component', () => {
  it('should render play button', () => {
    const wrapper = mount(AudioPlayer, {
      props: { text: 'Hello World' }
    });
    
    expect(wrapper.find('.play-btn').exists()).toBe(true);
  });

  it('should play audio on button click', async () => {
    const wrapper = mount(AudioPlayer, {
      props: { text: 'Hello World' }
    });
    
    const playButton = wrapper.find('.play-btn');
    await playButton.trigger('click');
    
    // éªŒè¯éŸ³é¢‘æ’­æ”¾é€»è¾‘
    expect(wrapper.emitted('play')).toBeTruthy();
  });
});
```

## ğŸ“‹ ä½¿ç”¨æ£€æŸ¥æ¸…å•

### éƒ¨ç½²å‰æ£€æŸ¥

- [ ] éŸ³é¢‘æ–‡ä»¶å·²æ­£ç¡®æ”¾ç½®åœ¨ `assets/sounds/` ç›®å½•
- [ ] TTS API å¯†é’¥å·²é…ç½®ï¼ˆå¦‚æœä½¿ç”¨ä»˜è´¹æœåŠ¡ï¼‰
- [ ] éŸ³é¢‘æ ¼å¼å…¼å®¹æ€§æµ‹è¯•å®Œæˆ
- [ ] ç§»åŠ¨ç«¯éŸ³é¢‘æ’­æ”¾æµ‹è¯•é€šè¿‡
- [ ] ç½‘ç»œå¼‚å¸¸æƒ…å†µçš„å…œåº•æ–¹æ¡ˆå·²å®ç°
- [ ] ç”¨æˆ·è®¾ç½®æŒä¹…åŒ–åŠŸèƒ½æ­£å¸¸
- [ ] é”®ç›˜å¿«æ·é”®åŠŸèƒ½æµ‹è¯•é€šè¿‡
- [ ] æ€§èƒ½ä¼˜åŒ–æªæ–½å·²å®æ–½

### åŠŸèƒ½éªŒè¯

- [ ] æ–‡æœ¬è½¬è¯­éŸ³æ’­æ”¾æ­£å¸¸
- [ ] å•è¯ç‚¹å‡»æ’­æ”¾åŠŸèƒ½æ­£å¸¸
- [ ] å¬å†™æ¨¡å¼æ’­æ”¾å‚æ•°å¯è°ƒèŠ‚
- [ ] é”®ç›˜éŸ³æ•ˆå¯å¼€å…³
- [ ] å‘éŸ³ç±»å‹åˆ‡æ¢æ­£å¸¸
- [ ] è‡ªåŠ¨æ’­æ”¾è®¾ç½®ç”Ÿæ•ˆ
- [ ] éŸ³é¢‘æ’­æ”¾é”™è¯¯å¤„ç†æ­£å¸¸

## ğŸ”— ç›¸å…³èµ„æº

### API æ–‡æ¡£
- [æœ‰é“è¯å…¸è¯­éŸ³ API](https://ai.youdao.com/DOCSIRMA/html/tts/api/ttsapi/index.html)
- [Web Audio API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)
- [HTML Audio Element](https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement)

### éŸ³æ•ˆèµ„æº
- [Freesound](https://freesound.org/) - å…è´¹éŸ³æ•ˆåº“
- [Zapsplat](https://www.zapsplat.com/) - ä¸“ä¸šéŸ³æ•ˆåº“
- [Adobe Audition](https://www.adobe.com/products/audition.html) - éŸ³é¢‘ç¼–è¾‘å·¥å…·

### æµ‹è¯•å·¥å…·
- [Web Audio API Test](https://webaudioapi.com/samples/) - Web Audio API æµ‹è¯•
- [Audio Format Support](https://caniuse.com/audio) - æµè§ˆå™¨éŸ³é¢‘æ ¼å¼æ”¯æŒæŸ¥è¯¢

---

é€šè¿‡éµå¾ªæœ¬æŒ‡å—ï¼Œæ‚¨å¯ä»¥åœ¨ä»»ä½• Vue.js/Nuxt.js é¡¹ç›®ä¸­å®ç°å®Œæ•´çš„æ–‡æœ¬è½¬è¯­éŸ³æ’­æ”¾ç³»ç»Ÿã€‚è¯¥ç³»ç»Ÿæä¾›äº†ä¸°å¯Œçš„åŠŸèƒ½ã€è‰¯å¥½çš„ç”¨æˆ·ä½“éªŒå’Œå¯é çš„é”™è¯¯å¤„ç†æœºåˆ¶ã€‚