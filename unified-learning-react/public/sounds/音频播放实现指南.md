# 文本转语音播放系统实现指南

## 📋 概述

本文档基于 Earthworm 英语学习应用的实现经验，详细介绍如何构建一个完整的文本转语音播放系统。该系统结合了第三方 TTS 服务和本地音效，提供了丰富的音频交互功能。

## 🏗️ 系统架构

```
音频播放系统
├── TTS 服务层 (有道词典 API)
├── 音频管理层 (HTML5 Audio)
├── 配置管理层 (用户偏好设置)
├── 音效系统层 (本地音频文件)
└── 业务逻辑层 (各种播放场景)
```

## 🚀 核心实现

### 1. 发音配置管理

首先创建发音类型和配置管理：

```typescript
// composables/user/pronunciation.ts

export enum PronunciationType {
  American = "American",
  British = "British",
}

export const pronunciationLabels: { [key in PronunciationType]: string } = {
  [PronunciationType.American]: "美音",
  [PronunciationType.British]: "英音",
};

const PRONUNCIATION_TYPE = "pronunciationType";
const pronunciation = ref<PronunciationType>(PronunciationType.American);

export function usePronunciation() {
  loadCache();

  function loadCache() {
    const type = getStore() || pronunciation.value;
    setStore(type);
  }

  function setStore(value: PronunciationType) {
    pronunciation.value = value;
    localStorage.setItem(PRONUNCIATION_TYPE, value);
  }

  function getStore(): PronunciationType {
    return localStorage.getItem(PRONUNCIATION_TYPE) as PronunciationType;
  }

  function getPronunciationType(): number {
    return pronunciation.value === PronunciationType.American ? 2 : 1;
  }

  function getPronunciationOptions() {
    return Object.entries(pronunciationLabels).map(([key, value]) => ({
      label: value,
      value: key,
    }));
  }

  /**
   * 生成有道词典 TTS API URL
   * 美式发音：type=2
   * 英式发音：type=1
   */
  function getPronunciationUrl(english: string | undefined): string {
    if (!english) return '';
    return `https://dict.youdao.com/dictvoice?type=${getPronunciationType()}&audio=${encodeURIComponent(english)}`;
  }

  function togglePronunciation(type: PronunciationType) {
    if (type !== pronunciation.value) setStore(type);
  }

  return {
    pronunciation,
    getPronunciationOptions,
    getPronunciationUrl,
    togglePronunciation,
  };
}
```

### 2. 核心音频播放器

创建基础的音频播放功能：

```typescript
// composables/audio/audioPlayer.ts

export interface PlayOptions {
  times?: number;      // 播放次数
  rate?: number;       // 播放速度 (0.5-2.0)
  interval?: number;   // 重复播放间隔 (毫秒)
}

const DefaultPlayOptions: PlayOptions = {
  times: 1,
  rate: 1,
  interval: 500,
};

// 全局音频实例
const globalAudio = new Audio();

export function updateAudioSource(src: string) {
  if (!src) return;
  
  globalAudio.src = src;
  globalAudio.load();
}

export function playAudio(playOptions?: PlayOptions) {
  const { times, rate, interval } = Object.assign({}, DefaultPlayOptions, playOptions);

  globalAudio.playbackRate = rate;
  
  // 播放音频
  const playPromise = globalAudio.play();
  
  // 处理播放失败的情况
  if (playPromise !== undefined) {
    playPromise.catch(error => {
      console.warn('音频播放失败:', error);
    });
  }

  // 多次播放逻辑
  if (times > 1) {
    globalAudio.addEventListener("ended", handleEnded, false);
  }

  let playCount = 1;
  let timeoutId: NodeJS.Timeout;

  function handleEnded() {
    if (playCount < times) {
      timeoutId = setTimeout(() => {
        globalAudio.play();
        playCount++;
      }, interval);
    } else {
      // 清理监听器
      globalAudio.removeEventListener("ended", handleEnded);
      playCount = 1;
    }
  }

  // 返回停止播放的函数
  return () => {
    globalAudio.pause();
    globalAudio.currentTime = 0;
    globalAudio.removeEventListener("ended", handleEnded);
    if (timeoutId) clearTimeout(timeoutId);
  };
}

/**
 * 单词级别的音频播放器
 * 避免重复播放相同单词
 */
export function useWordAudioPlayer() {
  const wordAudio = new Audio();
  let lastWord = "";
  let isPlaying = false;

  wordAudio.onplay = () => {
    isPlaying = true;
  };

  wordAudio.onended = () => {
    isPlaying = false;
  };

  wordAudio.onerror = () => {
    isPlaying = false;
    console.warn('单词音频播放失败:', lastWord);
  };

  function playWord(word: string, pronunciationUrl: string) {
    // 如果正在播放相同单词，则跳过
    if (isPlaying && lastWord === word) {
      return;
    }

    lastWord = word;
    wordAudio.src = pronunciationUrl;
    
    const playPromise = wordAudio.play();
    if (playPromise !== undefined) {
      playPromise.catch(error => {
        console.warn('单词播放失败:', word, error);
      });
    }
  }

  return {
    playWord,
    isPlaying: () => isPlaying,
  };
}
```

### 3. TTS 服务集成

创建文本转语音的核心服务：

```typescript
// composables/audio/ttsService.ts

import { watchEffect } from "vue";
import { usePronunciation } from "../user/pronunciation";
import { updateAudioSource, playAudio, type PlayOptions } from "./audioPlayer";

export function useTTSService() {
  const { getPronunciationUrl } = usePronunciation();
  let lastPronunciationUrl = "";

  /**
   * 为指定文本设置音频源
   */
  function setTextAudio(text: string) {
    if (!text) return;
    
    const pronunciationUrl = getPronunciationUrl(text);
    if (lastPronunciationUrl !== pronunciationUrl) {
      updateAudioSource(pronunciationUrl);
      lastPronunciationUrl = pronunciationUrl;
    }
  }

  /**
   * 播放指定文本的语音
   */
  function speakText(text: string, options?: PlayOptions) {
    setTextAudio(text);
    return playAudio(options);
  }

  /**
   * 播放当前设置的音频
   */
  function speak(options?: PlayOptions) {
    return playAudio(options);
  }

  return {
    setTextAudio,
    speakText,
    speak,
  };
}

/**
 * 响应式文本语音播放
 * 当文本变化时自动更新音频源
 */
export function useReactiveTTS(textRef: Ref<string | undefined>) {
  const { setTextAudio, speak } = useTTSService();

  // 监听文本变化，自动更新音频源
  watchEffect(() => {
    const text = textRef.value;
    if (text) {
      setTextAudio(text);
    }
  });

  return {
    speak,
  };
}
```

### 4. 用户偏好设置

创建音频相关的用户设置：

```typescript
// composables/user/audioSettings.ts

import { useLocalStorageBoolean } from "~/utils/localStorage";

// 存储键名常量
export const AUTO_PRONUNCIATION = "autoPronunciation";
export const KEYBOARD_SOUND_KEY = "keyboardSoundEnabled";
export const AUTO_PLAY_ENGLISH = "autoPlayEnglish";

/**
 * 自动发音设置
 */
export function useAutoPronunciation() {
  const {
    value: autoPlaySound,
    isTrue: isAutoPlaySound,
    toggle: toggleAutoPlaySound,
    remove: removeAutoPlaySound,
  } = useLocalStorageBoolean(AUTO_PRONUNCIATION, true);

  return {
    autoPlaySound,
    isAutoPlaySound,
    toggleAutoPlaySound,
    removeAutoPlaySound,
  };
}

/**
 * 键盘音效设置
 */
export function useKeyboardSound() {
  const {
    value: keyboardSound,
    isTrue: isKeyboardSoundEnabled,
    toggle: toggleKeyboardSound,
    remove: removeKeyboardSound,
  } = useLocalStorageBoolean(KEYBOARD_SOUND_KEY, true);

  return {
    keyboardSound,
    isKeyboardSoundEnabled,
    toggleKeyboardSound,
    removeKeyboardSound,
  };
}

/**
 * 自动播放英语设置
 */
export function useAutoPlayEnglish() {
  const {
    value: autoPlayEnglish,
    isTrue: isAutoPlayEnglish,
    toggle: toggleAutoPlayEnglish,
    remove: removeAutoPlayEnglish,
  } = useLocalStorageBoolean(AUTO_PLAY_ENGLISH, true);

  return {
    autoPlayEnglish,
    isAutoPlayEnglish,
    toggleAutoPlayEnglish,
    removeAutoPlayEnglish,
  };
}

// localStorage 布尔值工具函数
export function useLocalStorageBoolean(key: string, defaultValue: boolean = false) {
  const value = ref(defaultValue);

  // 初始化时从 localStorage 读取
  const stored = localStorage.getItem(key);
  if (stored !== null) {
    value.value = stored === 'true';
  } else {
    localStorage.setItem(key, String(defaultValue));
  }

  const isTrue = () => value.value;
  const isFalse = () => !value.value;
  
  const toggle = () => {
    value.value = !value.value;
    localStorage.setItem(key, String(value.value));
  };

  const set = (newValue: boolean) => {
    value.value = newValue;
    localStorage.setItem(key, String(newValue));
  };

  const remove = () => {
    localStorage.removeItem(key);
    value.value = defaultValue;
  };

  return {
    value,
    isTrue,
    isFalse,
    toggle,
    set,
    remove,
  };
}
```

### 5. 本地音效系统

实现键盘音效和提示音：

```typescript
// composables/audio/soundEffects.ts

// 音效文件路径
import errorSoundPath from "~/assets/sounds/error.mp3";
import rightSoundPath from "~/assets/sounds/right.mp3";
import typingSoundPath from "~/assets/sounds/typing.mp3";

/**
 * 提示音播放器
 */
export function useTipSounds() {
  const rightAudio = new Audio(rightSoundPath);
  const errorAudio = new Audio(errorSoundPath);

  // 预加载音频
  rightAudio.preload = 'auto';
  errorAudio.preload = 'auto';

  function playRightSound() {
    rightAudio.currentTime = 0; // 重置播放位置
    rightAudio.play().catch(console.warn);
  }

  function playErrorSound() {
    errorAudio.currentTime = 0;
    errorAudio.play().catch(console.warn);
  }

  return {
    playRightSound,
    playErrorSound,
  };
}

/**
 * 键盘打字音效
 * 使用 Web Audio API 实现低延迟播放
 */
export function useTypingSounds() {
  const PLAY_INTERVAL_TIME = 60; // 播放间隔限制 (毫秒)
  const lastPlayTime = ref(0);
  
  let audioCtx: AudioContext | null = null;
  let audioBuffer: AudioBuffer | null = null;

  // 初始化音频上下文
  async function initAudioContext() {
    if (!audioCtx) {
      audioCtx = new AudioContext();
      await loadAudioBuffer();
    }
  }

  // 加载音频缓冲区
  async function loadAudioBuffer() {
    if (!audioCtx) return;

    try {
      const response = await fetch(typingSoundPath);
      const arrayBuffer = await response.arrayBuffer();
      audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
    } catch (error) {
      console.warn('加载打字音效失败:', error);
    }
  }

  // 播放打字音效
  function playTypingSound() {
    const now = Date.now();
    
    // 频率限制
    if (now - lastPlayTime.value < PLAY_INTERVAL_TIME) return;
    if (!audioCtx || !audioBuffer) return;

    try {
      const source = audioCtx.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(audioCtx.destination);
      source.start();
      
      lastPlayTime.value = now;
      
      // 播放结束后清理资源
      source.onended = () => {
        source.disconnect();
      };
    } catch (error) {
      console.warn('播放打字音效失败:', error);
    }
  }

  // 检查是否应该播放打字音效
  function shouldPlayTypingSound(e: KeyboardEvent): boolean {
    // 忽略修饰键
    if (e.altKey || e.ctrlKey || e.metaKey) return false;
    
    // 只对字母数字和特定符号播放音效
    return /^[a-zA-Z0-9]$/.test(e.key) || ["Backspace", " ", "'"].includes(e.key);
  }

  // 初始化（在组件挂载时调用）
  onMounted(() => {
    initAudioContext();
  });

  return {
    playTypingSound,
    shouldPlayTypingSound,
  };
}
```

### 6. 业务场景实现

#### A. 句子朗读组件

```typescript
// composables/business/sentenceReader.ts

export function useSentenceReader(sentenceRef: Ref<string | undefined>) {
  const { speak } = useReactiveTTS(sentenceRef);
  const { isAutoPlaySound } = useAutoPronunciation();

  // 自动播放（在组件挂载时）
  onMounted(() => {
    if (isAutoPlaySound()) {
      speak();
    }
  });

  // 手动播放
  function playSentence(options?: PlayOptions) {
    return speak(options);
  }

  return {
    playSentence,
  };
}
```

#### B. 单词点击播放

```typescript
// composables/business/wordPlayer.ts

export function useWordPlayer() {
  const { getPronunciationUrl } = usePronunciation();
  const { playWord } = useWordAudioPlayer();

  function playWordSound(word: string) {
    if (!word) return;
    
    const pronunciationUrl = getPronunciationUrl(word);
    playWord(word, pronunciationUrl);
  }

  return {
    playWordSound,
  };
}
```

#### C. 听写模式播放器

```typescript
// composables/business/dictationPlayer.ts

interface DictationOptions {
  times: number;
  rate: number;
  interval: number;
}

const DEFAULT_DICTATION_OPTIONS: DictationOptions = {
  times: 1,
  rate: 1,
  interval: 1000,
};

export function useDictationPlayer() {
  const options = reactive({ ...DEFAULT_DICTATION_OPTIONS });
  const { speak } = useTTSService();

  // 从本地存储恢复设置
  function loadOptions() {
    const stored = localStorage.getItem('dictationOptions');
    if (stored) {
      Object.assign(options, JSON.parse(stored));
    }
  }

  // 保存设置到本地存储
  function saveOptions() {
    localStorage.setItem('dictationOptions', JSON.stringify(options));
  }

  // 重置设置
  function resetOptions() {
    Object.assign(options, DEFAULT_DICTATION_OPTIONS);
  }

  // 播放听写音频
  function playDictation() {
    const { times, rate, interval } = options;
    return speak({ times, rate, interval });
  }

  // 初始化
  loadOptions();

  return {
    options,
    loadOptions,
    saveOptions,
    resetOptions,
    playDictation,
  };
}
```

### 7. Vue 组件使用示例

#### A. 基础语音播放组件

```vue
<template>
  <div class="audio-player">
    <!-- 播放按钮 -->
    <button 
      @click="handlePlay"
      class="play-btn"
      :disabled="!currentText"
    >
      <Icon name="speaker" />
      播放
    </button>

    <!-- 单词点击播放 -->
    <div class="words-container">
      <span 
        v-for="word in words" 
        :key="word"
        @click="playWord(word)"
        class="clickable-word"
      >
        {{ word }}
      </span>
    </div>

    <!-- 音标显示 -->
    <div class="phonetic" v-if="phonetic">
      {{ phonetic }}
    </div>
  </div>
</template>

<script setup lang="ts">
interface Props {
  text?: string;
  phonetic?: string;
  autoPlay?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  autoPlay: false,
});

const currentText = toRef(props, 'text');
const words = computed(() => currentText.value?.split(' ') || []);

// 使用句子阅读器
const { playSentence } = useSentenceReader(currentText);

// 使用单词播放器
const { playWordSound } = useWordPlayer();

// 手动播放
function handlePlay() {
  playSentence();
}

// 播放单词
function playWord(word: string) {
  playWordSound(word);
}
</script>

<style scoped>
.clickable-word {
  @apply cursor-pointer hover:text-blue-500 mx-1;
}

.play-btn {
  @apply flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50;
}

.phonetic {
  @apply text-gray-500 text-lg mt-2;
}
</style>
```

#### B. 听写模式组件

```vue
<template>
  <div class="dictation-player">
    <!-- 控制面板 -->
    <div class="controls">
      <div class="control-group">
        <label>播放次数:</label>
        <select v-model="options.times">
          <option v-for="n in 5" :key="n" :value="n">{{ n }}</option>
        </select>
      </div>

      <div class="control-group">
        <label>播放速度:</label>
        <select v-model="options.rate">
          <option value="0.5">0.5x</option>
          <option value="0.75">0.75x</option>
          <option value="1">1x</option>
          <option value="1.25">1.25x</option>
          <option value="1.5">1.5x</option>
        </select>
      </div>

      <div class="control-group">
        <label>间隔时间:</label>
        <select v-model="options.interval">
          <option value="500">0.5秒</option>
          <option value="1000">1秒</option>
          <option value="1500">1.5秒</option>
          <option value="2000">2秒</option>
        </select>
      </div>
    </div>

    <!-- 播放按钮 -->
    <button @click="play" class="play-button">
      <Icon name="play" />
      播放听写
    </button>
  </div>
</template>

<script setup lang="ts">
const { options, saveOptions, playDictation } = useDictationPlayer();

// 监听选项变化并保存
watch(options, saveOptions, { deep: true });

function play() {
  playDictation();
}
</script>
```

#### C. 设置面板组件

```vue
<template>
  <div class="audio-settings">
    <h3>音频设置</h3>

    <!-- 发音类型 -->
    <div class="setting-item">
      <label>发音类型:</label>
      <div class="radio-group">
        <label v-for="option in pronunciationOptions" :key="option.value">
          <input 
            type="radio" 
            :value="option.value"
            :checked="pronunciation === option.value"
            @change="togglePronunciation(option.value as PronunciationType)"
          />
          {{ option.label }}
        </label>
      </div>
    </div>

    <!-- 自动播放设置 -->
    <div class="setting-item">
      <label>
        <input 
          type="checkbox" 
          :checked="autoPlaySound"
          @change="toggleAutoPlaySound"
        />
        答题后自动播放发音
      </label>
    </div>

    <!-- 键盘音效 -->
    <div class="setting-item">
      <label>
        <input 
          type="checkbox" 
          :checked="keyboardSound"
          @change="toggleKeyboardSound"
        />
        启用键盘音效
      </label>
    </div>

    <!-- 自动播放英语 -->
    <div class="setting-item">
      <label>
        <input 
          type="checkbox" 
          :checked="autoPlayEnglish"
          @change="toggleAutoPlayEnglish"
        />
        题目显示时自动播放
      </label>
    </div>
  </div>
</template>

<script setup lang="ts">
const { 
  pronunciation, 
  getPronunciationOptions, 
  togglePronunciation 
} = usePronunciation();

const { autoPlaySound, toggleAutoPlaySound } = useAutoPronunciation();
const { keyboardSound, toggleKeyboardSound } = useKeyboardSound();
const { autoPlayEnglish, toggleAutoPlayEnglish } = useAutoPlayEnglish();

const pronunciationOptions = getPronunciationOptions();
</script>
```

### 8. 输入框音效集成

```vue
<template>
  <input
    v-model="inputValue"
    @keydown="handleKeydown"
    @input="handleInput"
    class="audio-input"
    placeholder="请输入内容..."
  />
</template>

<script setup lang="ts">
const inputValue = ref('');

const { isKeyboardSoundEnabled } = useKeyboardSound();
const { playTypingSound, shouldPlayTypingSound } = useTypingSounds();
const { playRightSound, playErrorSound } = useTipSounds();

function handleKeydown(e: KeyboardEvent) {
  // 播放键盘音效
  if (isKeyboardSoundEnabled() && shouldPlayTypingSound(e)) {
    playTypingSound();
  }
}

function handleInput() {
  // 可以在这里添加输入验证逻辑
  // 根据验证结果播放不同音效
}

// 验证成功时调用
function onValidationSuccess() {
  playRightSound();
}

// 验证失败时调用
function onValidationError() {
  playErrorSound();
}
</script>
```

## 🔧 工具函数

### 音频预加载工具

```typescript
// utils/audioPreloader.ts

export class AudioPreloader {
  private audioCache = new Map<string, HTMLAudioElement>();

  /**
   * 预加载音频文件
   */
  async preloadAudio(url: string): Promise<HTMLAudioElement> {
    if (this.audioCache.has(url)) {
      return this.audioCache.get(url)!;
    }

    const audio = new Audio();
    audio.preload = 'auto';
    
    return new Promise((resolve, reject) => {
      audio.addEventListener('canplaythrough', () => {
        this.audioCache.set(url, audio);
        resolve(audio);
      });

      audio.addEventListener('error', () => {
        reject(new Error(`Failed to load audio: ${url}`));
      });

      audio.src = url;
    });
  }

  /**
   * 批量预加载
   */
  async preloadMultiple(urls: string[]): Promise<void> {
    const promises = urls.map(url => this.preloadAudio(url));
    await Promise.allSettled(promises);
  }

  /**
   * 获取缓存的音频
   */
  getCachedAudio(url: string): HTMLAudioElement | null {
    return this.audioCache.get(url) || null;
  }

  /**
   * 清理缓存
   */
  clearCache(): void {
    this.audioCache.clear();
  }
}

// 全局实例
export const audioPreloader = new AudioPreloader();
```

### 音频状态管理

```typescript
// utils/audioStatus.ts

export enum AudioStatus {
  IDLE = 'idle',
  LOADING = 'loading',
  PLAYING = 'playing',
  PAUSED = 'paused',
  ERROR = 'error',
}

export function useAudioStatus() {
  const status = ref<AudioStatus>(AudioStatus.IDLE);
  const error = ref<string | null>(null);

  function setStatus(newStatus: AudioStatus, errorMessage?: string) {
    status.value = newStatus;
    error.value = errorMessage || null;
  }

  function isPlaying() {
    return status.value === AudioStatus.PLAYING;
  }

  function isLoading() {
    return status.value === AudioStatus.LOADING;
  }

  function hasError() {
    return status.value === AudioStatus.ERROR;
  }

  return {
    status: readonly(status),
    error: readonly(error),
    setStatus,
    isPlaying,
    isLoading,
    hasError,
  };
}
```

## 📦 资源文件准备

### 1. 音效文件

在项目中创建 `assets/sounds/` 目录，并准备以下音频文件：

```
assets/sounds/
├── typing.mp3      # 键盘打字音效
├── right.mp3       # 正确提示音
├── error.mp3       # 错误提示音
└── notification.mp3 # 通知音效
```

### 2. 音频文件要求

- **格式**: MP3 (兼容性最好)
- **大小**: 建议每个文件小于 100KB
- **时长**: 音效文件建议 0.1-1 秒
- **采样率**: 44.1kHz
- **比特率**: 128kbps

## 🛠️ 配置和优化

### 1. Nuxt.js 配置

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  // 预加载音频资源
  app: {
    head: {
      link: [
        { rel: 'preload', href: '/sounds/typing.mp3', as: 'audio' },
        { rel: 'preload', href: '/sounds/right.mp3', as: 'audio' },
        { rel: 'preload', href: '/sounds/error.mp3', as: 'audio' },
      ]
    }
  },

  // 静态资源配置
  nitro: {
    publicAssets: [
      {
        baseURL: '/sounds',
        dir: 'assets/sounds'
      }
    ]
  }
});
```

### 2. 性能优化建议

```typescript
// composables/audio/optimization.ts

/**
 * 音频性能优化工具
 */
export function useAudioOptimization() {
  // 防抖播放
  const debouncedPlay = debounce((playFn: () => void) => {
    playFn();
  }, 100);

  // 节流播放
  const throttledPlay = throttle((playFn: () => void) => {
    playFn();
  }, 200);

  // 检查音频支持
  function checkAudioSupport(): boolean {
    return !!(window.Audio);
  }

  // 检查 Web Audio API 支持
  function checkWebAudioSupport(): boolean {
    return !!(window.AudioContext || window.webkitAudioContext);
  }

  // 获取音频格式支持
  function getSupportedFormats(): string[] {
    const audio = new Audio();
    const formats = ['mp3', 'wav', 'ogg', 'aac'];
    
    return formats.filter(format => {
      return audio.canPlayType(`audio/${format}`) !== '';
    });
  }

  return {
    debouncedPlay,
    throttledPlay,
    checkAudioSupport,
    checkWebAudioSupport,
    getSupportedFormats,
  };
}

// 防抖函数
function debounce(func: Function, wait: number) {
  let timeout: NodeJS.Timeout;
  return function executedFunction(...args: any[]) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// 节流函数
function throttle(func: Function, limit: number) {
  let inThrottle: boolean;
  return function executedFunction(...args: any[]) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}
```

## 🚨 错误处理和兜底方案

### 1. 音频播放失败处理

```typescript
// composables/audio/errorHandling.ts

export function useAudioErrorHandling() {
  const retryCount = ref(0);
  const maxRetries = 3;

  async function playWithRetry(
    playFn: () => Promise<void>, 
    onError?: (error: Error) => void
  ) {
    try {
      await playFn();
      retryCount.value = 0; // 重置重试次数
    } catch (error) {
      console.warn('音频播放失败:', error);
      
      if (retryCount.value < maxRetries) {
        retryCount.value++;
        setTimeout(() => playWithRetry(playFn, onError), 1000);
      } else {
        onError?.(error as Error);
        retryCount.value = 0;
      }
    }
  }

  function handleAudioError(error: Error) {
    // 记录错误
    console.error('音频系统错误:', error);
    
    // 显示用户友好的提示
    showErrorNotification('音频播放出现问题，请检查网络连接');
    
    // 发送错误报告（可选）
    // reportError(error);
  }

  return {
    playWithRetry,
    handleAudioError,
  };
}

function showErrorNotification(message: string) {
  // 实现错误提示逻辑
  console.warn(message);
}
```

### 2. 网络状态检测

```typescript
// composables/audio/networkStatus.ts

export function useNetworkAudioFallback() {
  const isOnline = ref(navigator.onLine);
  const useOfflineMode = ref(false);

  // 监听网络状态
  window.addEventListener('online', () => {
    isOnline.value = true;
    useOfflineMode.value = false;
  });

  window.addEventListener('offline', () => {
    isOnline.value = false;
    useOfflineMode.value = true;
  });

  function getAudioUrl(text: string): string {
    if (useOfflineMode.value) {
      // 离线模式下的兜底方案
      return getFallbackAudioUrl(text);
    }
    
    // 在线模式使用 TTS 服务
    const { getPronunciationUrl } = usePronunciation();
    return getPronunciationUrl(text);
  }

  function getFallbackAudioUrl(text: string): string {
    // 返回本地音频文件或静默音频
    return '/sounds/silence.mp3';
  }

  return {
    isOnline: readonly(isOnline),
    useOfflineMode: readonly(useOfflineMode),
    getAudioUrl,
  };
}
```

## 📱 移动端适配

### 1. 触摸事件处理

```typescript
// composables/audio/mobileSupport.ts

export function useMobileAudioSupport() {
  const isMobile = ref(false);
  const audioContext = ref<AudioContext | null>(null);

  onMounted(() => {
    // 检测移动设备
    isMobile.value = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
      navigator.userAgent
    );

    // 移动端需要用户交互才能播放音频
    if (isMobile.value) {
      document.addEventListener('touchstart', initAudioContext, { once: true });
      document.addEventListener('click', initAudioContext, { once: true });
    }
  });

  function initAudioContext() {
    if (!audioContext.value) {
      audioContext.value = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    // 恢复音频上下文
    if (audioContext.value.state === 'suspended') {
      audioContext.value.resume();
    }
  }

  return {
    isMobile: readonly(isMobile),
    audioContext: readonly(audioContext),
    initAudioContext,
  };
}
```

### 2. 音频权限处理

```typescript
// composables/audio/permissions.ts

export function useAudioPermissions() {
  const hasPermission = ref(false);
  const permissionStatus = ref<'granted' | 'denied' | 'prompt'>('prompt');

  async function requestAudioPermission(): Promise<boolean> {
    try {
      // 尝试播放静音音频来获取权限
      const audio = new Audio();
      audio.volume = 0;
      audio.muted = true;
      
      await audio.play();
      audio.pause();
      
      hasPermission.value = true;
      permissionStatus.value = 'granted';
      return true;
    } catch (error) {
      hasPermission.value = false;
      permissionStatus.value = 'denied';
      return false;
    }
  }

  return {
    hasPermission: readonly(hasPermission),
    permissionStatus: readonly(permissionStatus),
    requestAudioPermission,
  };
}
```

## 🧪 测试用例

### 1. 单元测试

```typescript
// tests/audio.spec.ts

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { useTTSService } from '~/composables/audio/ttsService';

// Mock Audio API
global.Audio = vi.fn(() => ({
  play: vi.fn().mockResolvedValue(undefined),
  pause: vi.fn(),
  load: vi.fn(),
  addEventListener: vi.fn(),
  removeEventListener: vi.fn(),
  src: '',
  currentTime: 0,
  playbackRate: 1,
}));

describe('TTS Service', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should create audio instance', () => {
    const { speakText } = useTTSService();
    expect(speakText).toBeDefined();
  });

  it('should play text audio', async () => {
    const { speakText } = useTTSService();
    const mockAudio = new Audio();
    
    await speakText('hello world');
    
    expect(mockAudio.play).toHaveBeenCalled();
  });

  it('should handle play options', async () => {
    const { speakText } = useTTSService();
    const mockAudio = new Audio();
    
    await speakText('hello', { rate: 1.5, times: 2 });
    
    expect(mockAudio.playbackRate).toBe(1.5);
  });
});
```

### 2. 集成测试

```typescript
// tests/integration/audioPlayer.spec.ts

import { mount } from '@vue/test-utils';
import AudioPlayer from '~/components/AudioPlayer.vue';

describe('AudioPlayer Component', () => {
  it('should render play button', () => {
    const wrapper = mount(AudioPlayer, {
      props: { text: 'Hello World' }
    });
    
    expect(wrapper.find('.play-btn').exists()).toBe(true);
  });

  it('should play audio on button click', async () => {
    const wrapper = mount(AudioPlayer, {
      props: { text: 'Hello World' }
    });
    
    const playButton = wrapper.find('.play-btn');
    await playButton.trigger('click');
    
    // 验证音频播放逻辑
    expect(wrapper.emitted('play')).toBeTruthy();
  });
});
```

## 📋 使用检查清单

### 部署前检查

- [ ] 音频文件已正确放置在 `assets/sounds/` 目录
- [ ] TTS API 密钥已配置（如果使用付费服务）
- [ ] 音频格式兼容性测试完成
- [ ] 移动端音频播放测试通过
- [ ] 网络异常情况的兜底方案已实现
- [ ] 用户设置持久化功能正常
- [ ] 键盘快捷键功能测试通过
- [ ] 性能优化措施已实施

### 功能验证

- [ ] 文本转语音播放正常
- [ ] 单词点击播放功能正常
- [ ] 听写模式播放参数可调节
- [ ] 键盘音效可开关
- [ ] 发音类型切换正常
- [ ] 自动播放设置生效
- [ ] 音频播放错误处理正常

## 🔗 相关资源

### API 文档
- [有道词典语音 API](https://ai.youdao.com/DOCSIRMA/html/tts/api/ttsapi/index.html)
- [Web Audio API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)
- [HTML Audio Element](https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement)

### 音效资源
- [Freesound](https://freesound.org/) - 免费音效库
- [Zapsplat](https://www.zapsplat.com/) - 专业音效库
- [Adobe Audition](https://www.adobe.com/products/audition.html) - 音频编辑工具

### 测试工具
- [Web Audio API Test](https://webaudioapi.com/samples/) - Web Audio API 测试
- [Audio Format Support](https://caniuse.com/audio) - 浏览器音频格式支持查询

---

通过遵循本指南，您可以在任何 Vue.js/Nuxt.js 项目中实现完整的文本转语音播放系统。该系统提供了丰富的功能、良好的用户体验和可靠的错误处理机制。