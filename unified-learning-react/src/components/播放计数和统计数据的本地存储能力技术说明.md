# FullSentenceDisplay 组件技术文档

## 概述

FullSentenceDisplay 是一个 React 组件，用于显示完整句子并提供音频播放功能，支持单次播放和循环播放模式，具备播放计数和统计数据的本地存储能力。

## 核心功能特性

### 1. 音频播放模式
- **单次播放模式**：播放一次音频后自动停止
- **循环播放模式**：无限循环播放音频，支持实时计数

### 2. 播放计数机制
- 实时跟踪循环播放次数
- 精确检测每次循环完成
- 支持页面刷新/关闭时的数据持久化

### 3. 统计数据记录
- 播放时长统计
- 播放次数统计
- 实时和批量两种记录模式

## 技术实现细节

### 音频播放控制

#### 音频实例管理
```typescript
// 单次播放音频实例
const audioRef = useRef<HTMLAudioElement | null>(null);

// 循环播放音频实例
const loopAudioRef = useRef<HTMLAudioElement | null>(null);
```

#### URL 处理逻辑
```typescript
// 统一处理音频URL，支持多种格式
let processedUrl = audioUrl;
if (audioUrl.startsWith('http://localhost:18080') || audioUrl.startsWith('http://127.0.0.1:18080')) {
  processedUrl = audioUrl;
} else if (audioUrl.startsWith('/api/learning/audio/')) {
  processedUrl = `http://127.0.0.1:18080${audioUrl}`;
} else if (!audioUrl.startsWith('http')) {
  processedUrl = `http://127.0.0.1:18080${audioUrl.startsWith('/') ? '' : '/'}${audioUrl}`;
}
```

### 循环播放计数实现

#### 循环检测机制
使用 `timeupdate` 事件精确检测每次循环完成：

```typescript
loopAudio.addEventListener('timeupdate', () => {
  const currentTime = loopAudio.currentTime;
  const duration = loopAudio.duration;
  
  // 检测音频接近结束（最后0.2秒内）
  if (duration > 0 && currentTime > duration - 0.2 && 
      currentTime > loopCountRef.current.lastUpdateTime && 
      !loopCountRef.current.hasCountedThisLoop) {
    
    // 增加播放计数
    setLoopPlayCount(prev => prev + 1);
    loopCountRef.current.hasCountedThisLoop = true;
    
    // 实时记录统计
    const playTime = audioDurationRef.current > 0 ? audioDurationRef.current : 3;
    onPlayRecord?.(fullText, playTime, 1);
  }
  
  // 检测音频重新开始，重置计数标志
  if (currentTime < 0.2 && loopCountRef.current.lastUpdateTime > duration - 0.2) {
    loopCountRef.current.hasCountedThisLoop = false;
  }
  
  loopCountRef.current.lastUpdateTime = currentTime;
});
```

#### 状态管理引用
```typescript
const loopCountRef = useRef({
  hasCountedThisLoop: false,    // 当前循环是否已计数
  lastUpdateTime: 0             // 上次更新时间戳
});
```

### 统计数据本地存储

#### 实时记录模式
```typescript
// 每次循环完成时立即记录
realtimeRecordRef.current = true;
onPlayRecord?.(fullText, playTime, 1);
```

#### 批量记录模式（页面离开时）
```typescript
// 使用 ref 保存最新状态，避免 effect 依赖问题
const latestIsLoopingRef = useRef(false);
const latestLoopCountRef = useRef(0);
const latestOnPlayRecordRef = useRef(onPlayRecord);
const latestFullTextRef = useRef(fullText);

// 页面卸载/离开时批量记录
const handleBeforeUnload = (e: BeforeUnloadEvent) => {
  if (!realtimeRecordRef.current && latestIsLoopingRef.current && 
      latestLoopCountRef.current > 0 && latestOnPlayRecordRef.current) {
    
    const totalPlayTime = latestLoopCountRef.current * 
      (audioDurationRef.current > 0 ? audioDurationRef.current : 3);
    
    latestOnPlayRecordRef.current(
      latestFullTextRef.current, 
      totalPlayTime, 
      latestLoopCountRef.current
    );
  }
};
```

### 生命周期管理

#### 组件挂载/更新
```typescript
// 同步最新状态到 ref
React.useEffect(() => {
  latestIsLoopingRef.current = isLooping;
  latestLoopCountRef.current = loopPlayCount;
  latestOnPlayRecordRef.current = onPlayRecord;
  latestFullTextRef.current = fullText;
}, []);
```

#### 组件卸载清理
```typescript
React.useEffect(() => {
  return () => {
    // 记录未实时统计的循环播放数据
    if (!realtimeRecordRef.current && latestIsLoopingRef.current && 
        latestLoopCountRef.current > 0 && latestOnPlayRecordRef.current) {
      // 批量记录逻辑...
    }
    
    // 清理音频资源
    if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current.currentTime = 0;
    }
    if (loopAudioRef.current) {
      loopAudioRef.current.pause();
      loopAudioRef.current.currentTime = 0;
    }
  };
}, []);
```

## 性能优化策略

### 1. 音频资源管理
- 播放前清理旧实例，避免事件堆叠
- 使用 `pause()`、`currentTime = 0` 和 `load()` 彻底清理
- 组件卸载时释放所有音频资源

### 2. 状态更新优化
- 使用 `useRef` 避免不必要的重渲染
- 批量状态更新减少渲染次数
- 事件监听器合理绑定和解绑

### 3. 内存泄漏防护
- 所有事件监听器都有对应的清理逻辑
- 音频实例在不再需要时及时释放
- 引用在组件生命周期内保持一致

## 错误处理机制

### 音频加载错误
```typescript
audio.addEventListener('error', (e) => {
  console.error('音频加载错误:', e);
  setIsPlaying(false);
  setIsLoading(false);
});
```

### 播放失败处理
```typescript
try {
  await audio.play();
  setIsPlaying(true);
} catch (error) {
  console.error('播放音频失败:', error);
  setIsPlaying(false);
} finally {
  setIsLoading(false);
}
```

## 数据流架构

```
音频播放事件 → 循环检测 → 计数更新 → 统计记录 → 本地存储
    ↓           ↓          ↓          ↓           ↓
timeupdate → 接近结束 → setLoopPlayCount → onPlayRecord → 持久化存储
```

## 使用注意事项

1. **音频URL格式**：组件支持多种URL格式，但需要确保音频服务器可访问
2. **统计回调**：`onPlayRecord` 回调函数需要由父组件提供实际的存储逻辑
3. **性能考虑**：循环播放会持续占用音频资源，建议合理控制并发播放数量
4. **浏览器兼容性**：依赖HTML5 Audio API，现代浏览器支持良好

## 扩展建议

1. **统计可视化**：可以添加播放统计数据的图表展示
2. **播放列表**：支持多个句子的连续播放
3. **播放速度控制**：添加变速播放功能
4. **离线存储**：集成IndexedDB或localStorage进行数据持久化

该组件提供了完整的音频播放和统计功能框架，可以根据具体业务需求进行扩展和定制。