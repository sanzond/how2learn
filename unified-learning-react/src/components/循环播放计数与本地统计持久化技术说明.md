# FullSentenceDisplay 循环播放计数与本地统计持久化技术说明

本文档说明 unified-learning-react/src/components/FullSentenceDisplay.tsx 中“循环播放（loop）计数”与“统计数据本地持久化”的完整实现链路与技术细节，包括状态设计、事件触发、边界处理、数据模型与本地存储策略。

## 1. 功能目标与总体设计

- 单次播放：播放结束时增加播放次数（+1），并累计播放时长。
- 循环播放：每完成一次循环，实时增加播放次数（+1），并累计本次循环对应的时长（优先用真实 duration，缺省时回退到 3 秒）。
- 持久化：所有播放记录（次数、总时长、会话维度等）写入浏览器 localStorage，支持统计视图展示与导入/导出、清空。

职责划分：
- FullSentenceDisplay：实现音频播放（单次/循环）、计数与回调触发。
- App.tsx：将组件的 onPlayRecord 回调接入 sentenceTrackingManager.recordPlay。
- utils/localStorage.ts：提供 LocalStorageManager（通用封装）与 SentenceTrackingManager（领域模型：句子播放记录与统计）。

## 2. FullSentenceDisplay 关键实现

文件：`src/components/FullSentenceDisplay.tsx`

### 2.1 核心状态与引用

- isLooping, isLoopLoading：循环播放开关与加载态。
- loopPlayCount：循环已完成次数的 UI 计数。
- loopAudioRef：循环播放的 HTMLAudioElement 实例。
- loopCountRef：{ hasCountedThisLoop: boolean, lastUpdateTime: number }
  - 防抖/去重：确保每个循环仅计数一次。
  - lastUpdateTime：跟踪 timeupdate 的时间前进，辅助判断“接近尾部一次”和“回到起点”。
- audioDurationRef：音频时长缓存（秒）。优先用 loadedmetadata 的真实 duration。
- realtimeRecordRef：是否采用“实时记录模式”。循环播放时设为 true，表示每次循环完成即刻写入统计；在 beforeunload 或 unmount 时将根据该标志决定是否需要补录。

另有 latestIsLoopingRef、latestLoopCountRef、latestOnPlayRecordRef、latestFullTextRef 用于在页面卸载/离开阶段获取最新（而非闭包内过期）值，避免在 effect 依赖变动导致的回调引用陈旧问题。

### 2.2 单次播放计数

- 创建非循环 Audio 实例（audio.loop = false）。
- 在 ended 事件中：
  - setIsPlaying(false)
  - 计算 playTime：优先使用 audioDurationRef.current，否则回退到 audio.duration 或 0。
  - 调用 onPlayRecord(fullText, playTime, 1)。

边界：
- error 事件：停止 loading，isPlaying=false。
- loadedmetadata：写入音频 duration 至 audioDurationRef。

### 2.3 循环播放计数（核心）

- 创建循环 Audio 实例（loopAudio.loop = true）。
- timeupdate 事件中（核心算法）：
  1. 读取 currentTime 与 duration。
  2. 当满足条件“接近结束、时间在前进、且本循环尚未计数”时进行计数：
     - 条件：duration > 0 且 currentTime > duration - 0.2 且 currentTime > lastUpdateTime 且 !hasCountedThisLoop
     - UI 计数：setLoopPlayCount(prev => prev + 1)
     - 标记：loopCountRef.current.hasCountedThisLoop = true
     - 立即写统计（实时模式）：计算 playTime = (audioDurationRef 或 loopAudio.duration 或 3)，调用 onPlayRecord(fullText, playTime, 1)
  3. 当 currentTime < 0.2 且 lastUpdateTime > duration - 0.2，判定“从尾部回到起点”，重置 hasCountedThisLoop=false。
  4. 更新 lastUpdateTime = currentTime。

- 停止循环（handleToggleLoop 内或 stopLoopAudio）：
  - 暂停并清理 loopAudioRef（pause、currentTime=0、清空 src、防止事件堆叠）。
  - setIsLooping(false)，setLoopPlayCount(0)，重置 loopCountRef。
  - realtimeRecordRef.current=false（实时模式下不在 stop 时二次记录）。

- 启动循环时：realtimeRecordRef.current=true，开始播放并置 isLooping=true。

边界与稳健性：
- 当无法得到可靠 duration 时，playTime 回退到 3 秒，确保统计不会为 0。
- 使用 “接近结束 0.2 秒” 的窗口，避免浮点误差和 timeupdate 步进差异导致漏计或多计。
- 结合 lastUpdateTime 避免在停顿或回退时重复计数。

### 2.4 页面离开与组件卸载的补录策略

- beforeunload 与组件卸载 useEffect：
  - 若处于循环播放且 loopPlayCount>0，且实时记录模式非开启（realtimeRecordRef.current === false）：
    - 使用最新引用的 isLooping、loopPlayCount、onPlayRecord、fullText。
    - 计算 duration（audioDurationRef 或 loopAudioRef.current?.duration），fallback 3 秒。
    - 计算 totalPlayTime = count * duration。
    - 调用 recordFn(sentence, totalPlayTime, count) 进行“补录”（汇总写入一次）。
- 由于本实现已在循环过程中采用实时写入（realtimeRecordRef=true），正常情况下不会在离开/卸载时再次写入，避免统计重复。只有实时记录未启用时才使用补录兜底。

### 2.5 资源清理

- 在新建音频实例前，若已有实例先 pause、重置 currentTime、清空 src、调用 load 以防事件泄漏和多实例并存。
- 组件卸载时，对 audioRef 与 loopAudioRef 做相同清理。

### 2.6 URL 处理健壮性

- 对传入的 audioUrl 进行前缀规范化：
  - 若是 /api/learning/audio/ 则拼接 http://127.0.0.1:18080 前缀。
  - 若非 http 开头的相对路径，同样拼接本地服务域名，保证 Audio 可加载。

## 3. 统计与持久化实现

### 3.1 回调接线

文件：`src/App.tsx`

- FullSentenceDisplay 的 `onPlayRecord={(sentence, playTime, increment=1) => sentenceTrackingManager.recordPlay(sentence, playTime, increment)}`。
- 即：组件只负责事件发生和参数计算，具体的持久化委托给统计管理器。

### 3.2 LocalStorageManager（通用封装）

文件：`src/utils/localStorage.ts`（上半部分）

- 提供 set/get/remove/has/clear/keys/getSize 等方法，并支持可选过期时间（expire）。
- 统一 try/catch 打印错误，避免 storage 写入异常导致崩溃。

### 3.3 SentenceTrackingManager（领域模型）

文件：`src/utils/localStorage.ts`（下半部分）

- key：`sentence_records`。
- 数据模型：
  ```ts
  interface SentenceRecord {
    sentence: string;
    playCount: number;
    lastPlayed: number;
    firstPlayed: number;
    totalPlayTime: number; // 秒
    sessions: SessionRecord[];
  }
  interface SessionRecord {
    timestamp: number; // 会话起始时间
    playCount: number; // 本次会话内的新增次数
    playTime: number;  // 本次会话内新增的总播放时长（秒）
  }
  ```
- recordPlay(sentence, playTime, playCountIncrement=1)
  - 保障 increment >= 1（向下取整后再与 1 取大值）。
  - 顶层聚合字段更新：playCount += inc；totalPlayTime += max(0, playTime)；lastPlayed=now。
  - 会话合并策略：30 分钟无活动即新会话，否则合并到最近会话（累计 playCount 与 playTime）。
  - 最后将 records 写回 localStorageManager。

- normalizeRecords()：用于历史数据校正
  - 以 sessions 汇总（sumCount/sumTime）为准，若与顶层聚合不一致且 sumCount>0，则覆盖顶层的 playCount/totalPlayTime，保证数据一致性。
  - 基础防护：负值归零。
  - 在 getTotalStatistics() 前调用，确保统计口径一致。

- getTotalStatistics()
  - 汇总 totalSentences、totalPlayCount、totalPlayTime、averagePlayCount。
  - 输出调试信息以辅助定位异常。

- 其他：getAllRecords、getRecord、getMostPlayedSentences、getRecentlyPlayedSentences、clearAll、exportData、importData。

### 3.4 统计视图与数据管理

文件：`src/components/SentenceStatistics.tsx`

- 展示统计概览：总句子数、总播放次数、总播放时间、平均播放次数。
- 列表：播放次数最多、最近播放。
- 数据管理：导出/导入 JSON、本地清空。

## 4. 关键边界与可靠性策略

- 时长不可用：循环计数与补录均回退到 3 秒，避免 0 值。
- 漂移与重复计数防护：timeupdate 接近尾部（duration-0.2）窗口 + lastUpdateTime + hasCountedThisLoop。
- 实时记录与补录互斥：realtimeRecordRef 控制仅在“非实时模式”才会在 beforeunload/unmount 阶段进行补录，避免重复累计。
- 音频实例清理：严格 pause/重置/清 src/load，避免内存泄漏与事件重复触发。
- 数据一致性：normalizeRecords 在统计前做基于 sessions 的校正，且对负值进行修正。

## 5. 开发与测试建议

- 人工测试：
  - 单次播放：验证 ended 触发后计数+1、时长≈真实 duration。
  - 循环播放：长时间循环，观察 loopPlayCount 与统计变化；中途停止/页面刷新，确保无重复累计。
  - 异常网络/duration=NaN：验证 fallback=3 生效。
  - 会话划分：间隔 >30 分钟后继续播放，验证新会话创建。
- 自动化思路（可选）：
  - 抽象计数逻辑为纯函数进行单元测试（对临界阈值 0.2s、时间回绕进行模拟）。
  - 对 SentenceTrackingManager 的 recordPlay 和 normalizeRecords 进行基于样例数据的断言。

## 6. 变更影响面

- FullSentenceDisplay 的 onPlayRecord 是统计入口；若签名或传参变更（如不再提供 playTime 或 increment），需同步调整 SentenceTrackingManager.recordPlay 侧的处理和统计视图的展示逻辑。
- 若调整 duration 窗口阈值（0.2s），需回归测试以验证不漏计/不重计。

---

版本：v1.0  
维护者：自动生成（依据代码 2025-10-17）