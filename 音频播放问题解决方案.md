# 音频播放问题解决方案

## 问题描述

React 应用中无法播放 Odoo 学习系统生成的音频文件，音频URL格式如下：
```
http://127.0.0.1:18080/web/content/learning.set/3/audio_file/mentalStateSentences.mp3
```

## 更新说明

**2024-10-12 更新**：添加了自动音频生成功能，当音频文件不存在时，系统会自动调用 txt2audio API 生成音频文件。

## 问题根源分析

### 1. 虚拟文件存储
- 音频文件存储在 Odoo 数据库的 Binary 字段中，不是真实的文件系统文件
- 通过 Odoo 的 web 控制器动态生成和提供文件内容

### 2. 访问限制问题
- 原始 `/web/content/` URL 需要 Odoo 会话认证
- 第三方应用（如 React 应用）无法直接访问
- 存在跨域访问（CORS）限制

### 3. 路由问题
- Odoo 内部路由可能不对外完全开放
- 需要特殊的权限和会话管理

## 完整解决方案

### 1. 后端修改（Odoo 端）

#### 1.1 修改音频URL生成逻辑

**文件**: `learning_system/models/learning_set.py`

```python
@api.depends('audio_file', 'audio_filename')
def _compute_audio_url(self):
    """Compute URL for accessing the audio file"""
    for record in self:
        if record.audio_file and record.audio_filename:
            base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
            # 使用公开的API接口访问音频文件，避免认证和CORS问题
            record.audio_url = f"{base_url}/api/learning/audio/{record.id}"
        else:
            record.audio_url = False
```

#### 1.2 添加内部音频生成方法

**文件**: `learning_system/models/learning_set.py`

```python
def generate_txt2audio(self):
    """Generate audio using txt2audio API (internal method)"""
    if not self.full_text:
        raise UserError("请先填写完整文本内容(Full Text)才能使用语音生成功能")
    
    import logging
    _logger = logging.getLogger(__name__)
    
    try:
        _logger.info(f"开始为学习集 '{self.name}' 生成音频...")
        
        # Prepare API request
        url = "https://text2audio.cc/api/audio"
        headers = {"Content-Type": "application/json"}
        data = {
            "language": "en-US",
            "paragraphs": self.full_text,
            "splitParagraph": True
        }
        
        _logger.info(f"发送API请求到: {url}")
        
        # Make API request
        response = requests.post(url, json=data, headers=headers, timeout=30)
        response.raise_for_status()
        
        # Parse response
        audio_data = response.json()
        if not audio_data or not isinstance(audio_data, list) or not audio_data[0].get('url'):
            raise UserError("API返回数据格式错误")
        
        # Get the first audio URL
        audio_url = audio_data[0]['url']
        _logger.info(f"获取到音频URL: {audio_url}")
        
        # Download the MP3 file
        _logger.info("开始下载音频文件...")
        audio_response = requests.get(audio_url, timeout=60)
        audio_response.raise_for_status()
        
        # Encode audio content to base64
        audio_content = base64.b64encode(audio_response.content)
        
        # Generate filename
        filename = f"{self.name}.mp3"
        
        # Update the record
        self.write({
            'audio_file': audio_content,
            'audio_filename': filename
        })
        
        _logger.info(f"音频文件生成成功: {filename}, 大小: {len(audio_response.content)} 字节")
        
        return True
        
    except requests.exceptions.RequestException as e:
        _logger.error(f"API请求失败: {str(e)}")
        raise UserError(f"API请求失败: {str(e)}")
    except Exception as e:
        _logger.error(f"语音生成失败: {str(e)}")
        raise UserError(f"语音生成失败: {str(e)}")
```

#### 1.3 创建公开音频访问控制器

**文件**: `learning_system/controllers/audio_controller.py`

```python
from odoo import http
from odoo.http import request
import base64
import mimetypes
import logging

_logger = logging.getLogger(__name__)


class AudioController(http.Controller):
    
    @http.route('/api/learning/audio/<int:learning_set_id>', 
                type='http', auth='public', methods=['GET'], csrf=False, cors='*')
    def get_audio_file(self, learning_set_id, **kwargs):
        """
        公开接口：获取学习集的音频文件
        支持跨域访问，无需认证
        如果音频文件不存在，自动生成音频
        """
        try:
            # 查找学习集记录
            learning_set = request.env['learning.set'].sudo().browse(learning_set_id)
            
            if not learning_set.exists():
                return request.not_found("学习集不存在")
            
            # 如果音频文件不存在，尝试自动生成
            if not learning_set.audio_file:
                _logger.info(f"音频文件不存在，尝试为学习集 {learning_set_id} 自动生成音频")
                
                # 检查是否有完整文本内容
                if not learning_set.full_text:
                    _logger.warning(f"学习集 {learning_set_id} 没有完整文本内容，无法生成音频")
                    return request.not_found("音频文件不存在且无法自动生成：缺少文本内容")
                
                try:
                    # 调用音频生成方法（使用内部方法，不返回UI动作）
                    _logger.info(f"开始为学习集 {learning_set_id} 生成音频...")
                    learning_set.generate_txt2audio()
                    
                    # 重新获取记录以获取生成的音频文件
                    learning_set = request.env['learning.set'].sudo().browse(learning_set_id)
                    
                    if not learning_set.audio_file:
                        _logger.error(f"学习集 {learning_set_id} 音频生成失败")
                        return request.not_found("音频文件生成失败")
                    
                    _logger.info(f"学习集 {learning_set_id} 音频生成成功")
                    
                except Exception as gen_error:
                    _logger.error(f"学习集 {learning_set_id} 音频生成异常: {str(gen_error)}")
                    return request.not_found(f"音频文件自动生成失败: {str(gen_error)}")
            
            # 解码音频文件内容
            audio_content = base64.b64decode(learning_set.audio_file)
            
            # 设置响应头
            filename = learning_set.audio_filename or f"audio_{learning_set_id}.mp3"
            content_type = mimetypes.guess_type(filename)[0] or 'audio/mpeg'
            
            headers = [
                ('Content-Type', content_type),
                ('Content-Length', len(audio_content)),
                ('Content-Disposition', f'inline; filename="{filename}"'),
                ('Cache-Control', 'public, max-age=3600'),  # 缓存1小时
                ('Access-Control-Allow-Origin', '*'),  # 允许跨域
                ('Access-Control-Allow-Methods', 'GET'),
                ('Access-Control-Allow-Headers', 'Content-Type'),
            ]
            
            return request.make_response(audio_content, headers=headers)
            
        except Exception as e:
            _logger.error(f"获取音频文件失败 ID={learning_set_id}: {str(e)}")
            return request.not_found(f"音频文件访问失败: {str(e)}")
    
    @http.route('/api/learning/audio/test/<int:learning_set_id>', 
                type='json', auth='public', methods=['GET'], csrf=False, cors='*')
    def test_audio_access(self, learning_set_id, **kwargs):
        """
        测试接口：检查音频文件是否可访问
        """
        try:
            learning_set = request.env['learning.set'].sudo().browse(learning_set_id)
            
            if not learning_set.exists():
                return {'status': 'error', 'message': '学习集不存在'}
            
            if not learning_set.audio_file:
                return {'status': 'error', 'message': '音频文件不存在'}
            
            return {
                'status': 'success',
                'learning_set_id': learning_set_id,
                'learning_set_name': learning_set.name,
                'audio_filename': learning_set.audio_filename,
                'audio_url': learning_set.audio_url,
                'file_size': len(base64.b64decode(learning_set.audio_file)) if learning_set.audio_file else 0
            }
            
        except Exception as e:
            _logger.error(f"测试音频访问失败 ID={learning_set_id}: {str(e)}")
            return {'status': 'error', 'message': str(e)}
    
    @http.route('/api/learning/audio/generate/<int:learning_set_id>', 
                type='json', auth='public', methods=['POST'], csrf=False, cors='*')
    def generate_audio(self, learning_set_id, **kwargs):
        """
        手动触发音频生成接口
        """
        try:
            learning_set = request.env['learning.set'].sudo().browse(learning_set_id)
            
            if not learning_set.exists():
                return {'status': 'error', 'message': '学习集不存在'}
            
            if not learning_set.full_text:
                return {'status': 'error', 'message': '学习集没有完整文本内容，无法生成音频'}
            
            _logger.info(f"手动触发学习集 {learning_set_id} 音频生成")
            
            # 调用音频生成方法
            try:
                learning_set.generate_txt2audio()
                
                return {
                    'status': 'success',
                    'message': '音频生成成功',
                    'learning_set_id': learning_set_id,
                    'audio_filename': learning_set.audio_filename,
                    'audio_url': learning_set.audio_url,
                    'file_size': len(base64.b64decode(learning_set.audio_file)) if learning_set.audio_file else 0
                }
                
            except Exception as gen_error:
                _logger.error(f"学习集 {learning_set_id} 手动音频生成失败: {str(gen_error)}")
                return {'status': 'error', 'message': f'音频生成失败: {str(gen_error)}'}
            
        except Exception as e:
            _logger.error(f"手动音频生成接口异常 ID={learning_set_id}: {str(e)}")
            return {'status': 'error', 'message': str(e)}
```

#### 1.4 更新控制器导入文件

**文件**: `learning_system/controllers/__init__.py`

```python
from . import api_controller
from . import audio_controller
```

**文件**: `learning_system/__init__.py`

```python
from . import models
from . import controllers
```

## 新增功能特性

### 自动音频生成
- **智能检测**：当请求音频文件时自动检查是否存在
- **自动生成**：如果音频不存在但有文本内容，自动调用 txt2audio API 生成
- **透明处理**：对用户完全透明，无需手动干预
- **错误处理**：完善的错误处理和日志记录

### API 接口扩展
- **GET** `/api/learning/audio/{id}` - 获取音频文件（支持自动生成）
- **GET** `/api/learning/audio/test/{id}` - 测试音频状态（增强版）
- **POST** `/api/learning/audio/generate/{id}` - 手动触发音频生成

### 2. 前端修改（React 端）

#### 2.1 增强音频播放函数

**文件**: `unified-learning-react/src/App.tsx`

```javascript
// 播放音频函数
const playAudio = async () => {
  if (!learningData || !currentSet || !learningData[currentSet].audioUrl) {
    console.warn('音频URL不存在');
    return;
  }

  try {
    let audioUrl = learningData[currentSet].audioUrl;
    
    console.log('原始音频URL:', audioUrl);
    
    // 处理不同格式的音频URL
    if (audioUrl.startsWith('http://localhost:18080') || audioUrl.startsWith('http://127.0.0.1:18080')) {
      // 如果是完整的Odoo URL，直接使用（新的API接口支持跨域）
      console.log('使用完整URL访问音频:', audioUrl);
    } else if (audioUrl.startsWith('/api/learning/audio/')) {
      // 如果是相对路径的API接口，添加基础URL
      audioUrl = `http://127.0.0.1:18080${audioUrl}`;
      console.log('构建完整API URL:', audioUrl);
    } else if (!audioUrl.startsWith('http')) {
      // 其他相对路径，添加基础路径
      audioUrl = `http://127.0.0.1:18080${audioUrl.startsWith('/') ? '' : '/'}${audioUrl}`;
      console.log('构建完整URL:', audioUrl);
    }
    
    console.log('最终播放音频URL:', audioUrl);
    
    const audio = new Audio(audioUrl);
    
    // 添加事件监听器用于调试
    audio.addEventListener('loadstart', () => console.log('开始加载音频'));
    audio.addEventListener('canplay', () => console.log('音频准备就绪'));
    audio.addEventListener('loadeddata', () => console.log('音频数据加载完成'));
    audio.addEventListener('error', (e) => {
      console.error('音频加载错误:', e);
      console.error('错误的音频URL:', audioUrl);
      // 尝试测试音频接口
      testAudioAccess();
    });
    
    await audio.play();
    console.log('音频播放成功');
    
  } catch (error) {
    console.error('播放音频失败:', error);
    console.error('失败的音频URL:', learningData[currentSet].audioUrl);
  }
};

// 测试音频访问的辅助函数
const testAudioAccess = async () => {
  if (!learningData || !currentSet) return;
  
  try {
    // 从audioUrl中提取学习集ID
    const audioUrl = learningData[currentSet].audioUrl;
    const match = audioUrl.match(/\/api\/learning\/audio\/(\d+)/);
    if (match) {
      const learningSetId = match[1];
      const testUrl = `http://127.0.0.1:18080/api/learning/audio/test/${learningSetId}`;
      
      console.log('测试音频访问:', testUrl);
      const response = await fetch(testUrl, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });
      
      if (response.ok) {
        const result = await response.json();
        console.log('音频访问测试结果:', result);
      } else {
        console.error('音频访问测试失败:', response.status, response.statusText);
      }
    }
  } catch (error) {
    console.error('音频访问测试异常:', error);
  }
};
```

### 3. 测试工具

#### 3.1 API测试脚本

**文件**: `test_audio_api.py`

```python
#!/usr/bin/env python3
"""
测试音频API接口的脚本
用于验证新的音频访问接口是否正常工作
"""

import requests
import sys

def test_audio_api():
    """测试音频API接口"""
    base_url = "http://127.0.0.1:18080"
    
    # 测试学习集ID（需要根据实际情况调整）
    test_learning_set_id = 1
    
    print("=== 音频API测试 ===")
    print(f"基础URL: {base_url}")
    print(f"测试学习集ID: {test_learning_set_id}")
    print()
    
    # 1. 测试音频访问测试接口
    print("1. 测试音频访问测试接口...")
    test_url = f"{base_url}/api/learning/audio/test/{test_learning_set_id}"
    
    try:
        response = requests.get(test_url, timeout=10)
        print(f"   请求URL: {test_url}")
        print(f"   响应状态: {response.status_code}")
        
        if response.status_code == 200:
            try:
                result = response.json()
                print(f"   响应内容: {result}")
                
                if result.get('status') == 'success':
                    print("   ✅ 音频文件存在且可访问")
                    audio_url = result.get('audio_url')
                    if audio_url:
                        print(f"   音频URL: {audio_url}")
                else:
                    print(f"   ❌ 音频不可访问: {result.get('message')}")
                    
            except Exception as e:
                print(f"   ❌ JSON解析失败: {e}")
        else:
            print(f"   ❌ 请求失败: {response.text}")
            
    except requests.exceptions.RequestException as e:
        print(f"   ❌ 网络请求异常: {e}")
    
    print()
    
    # 2. 测试直接音频文件访问
    print("2. 测试直接音频文件访问...")
    audio_url = f"{base_url}/api/learning/audio/{test_learning_set_id}"
    
    try:
        response = requests.head(audio_url, timeout=10)  # 使用HEAD请求避免下载整个文件
        print(f"   请求URL: {audio_url}")
        print(f"   响应状态: {response.status_code}")
        
        if response.status_code == 200:
            print("   ✅ 音频文件可直接访问")
            
            # 检查响应头
            content_type = response.headers.get('Content-Type', 'unknown')
            content_length = response.headers.get('Content-Length', 'unknown')
            
            print(f"   Content-Type: {content_type}")
            print(f"   Content-Length: {content_length} bytes")
            
            # 检查CORS头
            cors_origin = response.headers.get('Access-Control-Allow-Origin', 'none')
            print(f"   CORS Origin: {cors_origin}")
            
        else:
            print(f"   ❌ 音频文件访问失败: {response.text}")
            
    except requests.exceptions.RequestException as e:
        print(f"   ❌ 网络请求异常: {e}")
    
    print()
    print("=== 测试完成 ===")

if __name__ == "__main__":
    test_audio_api()
```

## URL格式对比

### 旧格式（有问题）
```
http://127.0.0.1:18080/web/content/learning.set/3/audio_file/mentalStateSentences.mp3
```
**问题**：
- ❌ 需要 Odoo 会话认证
- ❌ 不支持跨域访问
- ❌ 第三方应用无法访问

### 新格式（解决方案）
```
http://127.0.0.1:18080/api/learning/audio/3
```
**优势**：
- ✅ 公开访问（无需认证）
- ✅ 支持跨域访问（CORS）
- ✅ 适当的缓存策略
- ✅ 完善的错误处理
- ✅ 第三方应用友好

## 部署步骤

### 1. 更新 Odoo 代码
1. 将新的控制器文件复制到对应目录
2. 更新模型文件中的 `_compute_audio_url` 方法
3. 更新控制器导入文件

### 2. 重启 Odoo 服务
```bash
# 重启 Odoo 服务以加载新的控制器
sudo systemctl restart odoo
# 或者
python3 odoo-bin -c /etc/odoo/odoo.conf
```

### 3. 更新模块
在 Odoo 后台更新 learning_system 模块

### 4. 测试验证
```bash
# 运行测试脚本
python3 test_audio_api.py

# 或指定学习集ID
python3 test_audio_api.py 3
```

### 5. 更新前端代码
将新的 `playAudio` 函数部署到 React 应用

## 故障排除

### 常见问题

#### 1. 404 错误
- **原因**：控制器未正确加载
- **解决**：检查 `__init__.py` 文件导入，重启 Odoo

#### 2. CORS 错误
- **原因**：跨域头设置不正确
- **解决**：检查控制器中的 CORS 头设置

#### 3. 音频文件不存在
- **原因**：学习集中没有上传音频文件
- **解决**：在 Odoo 后台上传音频文件

#### 4. 权限错误
- **原因**：数据库访问权限问题
- **解决**：使用 `sudo()` 方法提升权限

### 调试方法

1. **查看 Odoo 日志**
```bash
tail -f /var/log/odoo/odoo-server.log
```

2. **浏览器开发者工具**
- 检查网络请求
- 查看控制台错误信息

3. **使用测试脚本**
```bash
python3 test_audio_api.py
```

## 技术特点

### 安全性
- 使用公开认证但仍然通过 Odoo 权限系统
- 不暴露敏感的内部路径
- 适当的错误处理避免信息泄露

### 性能优化
- 内容缓存策略（1小时）
- 适当的 HTTP 头设置
- 流式内容传输

### 兼容性
- 支持所有现代浏览器
- 向后兼容现有代码
- 跨平台支持

## 总结

通过创建专门的公开API接口，我们成功解决了第三方应用无法播放 Odoo 存储音频文件的问题。新方案具有以下优势：

1. **无需认证**：第三方应用可直接访问
2. **跨域支持**：完整的CORS头设置
3. **性能优化**：适当的缓存和传输策略
4. **易于维护**：清晰的代码结构和错误处理
5. **向后兼容**：不影响现有功能

此解决方案为音频文件访问提供了稳定可靠的技术基础，支持各种第三方应用集成。